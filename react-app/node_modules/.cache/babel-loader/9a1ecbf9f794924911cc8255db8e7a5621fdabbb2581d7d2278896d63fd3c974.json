{"ast":null,"code":"export function validateAndFormatName(input) {\n  // Check if the name contains numbers or special characters\n  if (/\\d/.test(input) || /[!@#$%^&*()_+{}\\[\\]:;<>,.?~\\\\/]/.test(input)) {\n    return {\n      isValid: false,\n      formattedName: null\n    };\n  }\n\n  // Capitalize the first letter of every word\n  const words = input.split(' ');\n  const capitalizedWords = words.map(word => {\n    if (word.length > 0) {\n      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }\n    return word;\n  });\n  const formattedName = capitalizedWords.join(' ');\n  return {\n    isValid: true,\n    formattedName\n  };\n}\nexport function isValidDateFormat(input) {\n  // Regular expression to match \"YYYY-MM-DD\" format\n  const regex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  return regex.test(input);\n}\nexport function isValidDate(year, month, day) {\n  const dateObject = new Date(year, month - 1, day); // Month is 0-indexed\n  if (dateObject.getFullYear() !== year || dateObject.getMonth() !== month - 1 || dateObject.getDate() !== day) {\n    return false; // Invalid date\n  }\n\n  // Check if the input date is not beyond the present day\n  const currentDate = new Date();\n  if (dateObject > currentDate) {\n    return false; // Input date is in the future\n  }\n\n  // Check if the day is within the valid range for the given month\n  const lastDayOfMonth = new Date(year, month, 0).getDate();\n  if (day < 1 || day > lastDayOfMonth) {\n    return false; // Invalid day for the given month\n  }\n\n  return true; // Date is valid\n}","map":{"version":3,"names":["validateAndFormatName","input","test","isValid","formattedName","words","split","capitalizedWords","map","word","length","charAt","toUpperCase","slice","toLowerCase","join","isValidDateFormat","regex","isValidDate","year","month","day","dateObject","Date","getFullYear","getMonth","getDate","currentDate","lastDayOfMonth"],"sources":["C:/Users/Ramith/Projects/Application Scanner/scanner-app/src/components/validate.js"],"sourcesContent":["export function validateAndFormatName(input) {\r\n    // Check if the name contains numbers or special characters\r\n    if (/\\d/.test(input) || /[!@#$%^&*()_+{}\\[\\]:;<>,.?~\\\\/]/.test(input)) {\r\n        return { isValid: false, formattedName: null };\r\n    }\r\n\r\n    // Capitalize the first letter of every word\r\n    const words = input.split(' ');\r\n    const capitalizedWords = words.map((word) => {\r\n        if (word.length > 0) {\r\n            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\r\n        }\r\n        return word;\r\n    });\r\n\r\n    const formattedName = capitalizedWords.join(' ');\r\n\r\n    return { isValid: true, formattedName };\r\n}\r\n\r\nexport function isValidDateFormat(input) {\r\n    // Regular expression to match \"YYYY-MM-DD\" format\r\n    const regex = /^\\d{4}-\\d{2}-\\d{2}$/;\r\n\r\n    return regex.test(input);\r\n}\r\n\r\nexport function isValidDate(year, month, day) {\r\n    const dateObject = new Date(year, month - 1, day); // Month is 0-indexed\r\n    if (\r\n        dateObject.getFullYear() !== year ||\r\n        dateObject.getMonth() !== month - 1 ||\r\n        dateObject.getDate() !== day\r\n    ) {\r\n        return false; // Invalid date\r\n    }\r\n\r\n    // Check if the input date is not beyond the present day\r\n    const currentDate = new Date();\r\n    if (dateObject > currentDate) {\r\n        return false; // Input date is in the future\r\n    }\r\n\r\n    // Check if the day is within the valid range for the given month\r\n    const lastDayOfMonth = new Date(year, month, 0).getDate();\r\n    if (day < 1 || day > lastDayOfMonth) {\r\n        return false; // Invalid day for the given month\r\n    }\r\n\r\n    return true; // Date is valid\r\n}"],"mappings":"AAAA,OAAO,SAASA,qBAAqBA,CAACC,KAAK,EAAE;EACzC;EACA,IAAI,IAAI,CAACC,IAAI,CAACD,KAAK,CAAC,IAAI,iCAAiC,CAACC,IAAI,CAACD,KAAK,CAAC,EAAE;IACnE,OAAO;MAAEE,OAAO,EAAE,KAAK;MAAEC,aAAa,EAAE;IAAK,CAAC;EAClD;;EAEA;EACA,MAAMC,KAAK,GAAGJ,KAAK,CAACK,KAAK,CAAC,GAAG,CAAC;EAC9B,MAAMC,gBAAgB,GAAGF,KAAK,CAACG,GAAG,CAAEC,IAAI,IAAK;IACzC,IAAIA,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE;MACjB,OAAOD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGH,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACrE;IACA,OAAOL,IAAI;EACf,CAAC,CAAC;EAEF,MAAML,aAAa,GAAGG,gBAAgB,CAACQ,IAAI,CAAC,GAAG,CAAC;EAEhD,OAAO;IAAEZ,OAAO,EAAE,IAAI;IAAEC;EAAc,CAAC;AAC3C;AAEA,OAAO,SAASY,iBAAiBA,CAACf,KAAK,EAAE;EACrC;EACA,MAAMgB,KAAK,GAAG,qBAAqB;EAEnC,OAAOA,KAAK,CAACf,IAAI,CAACD,KAAK,CAAC;AAC5B;AAEA,OAAO,SAASiB,WAAWA,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAE;EAC1C,MAAMC,UAAU,GAAG,IAAIC,IAAI,CAACJ,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC,CAAC,CAAC;EACnD,IACIC,UAAU,CAACE,WAAW,CAAC,CAAC,KAAKL,IAAI,IACjCG,UAAU,CAACG,QAAQ,CAAC,CAAC,KAAKL,KAAK,GAAG,CAAC,IACnCE,UAAU,CAACI,OAAO,CAAC,CAAC,KAAKL,GAAG,EAC9B;IACE,OAAO,KAAK,CAAC,CAAC;EAClB;;EAEA;EACA,MAAMM,WAAW,GAAG,IAAIJ,IAAI,CAAC,CAAC;EAC9B,IAAID,UAAU,GAAGK,WAAW,EAAE;IAC1B,OAAO,KAAK,CAAC,CAAC;EAClB;;EAEA;EACA,MAAMC,cAAc,GAAG,IAAIL,IAAI,CAACJ,IAAI,EAAEC,KAAK,EAAE,CAAC,CAAC,CAACM,OAAO,CAAC,CAAC;EACzD,IAAIL,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAGO,cAAc,EAAE;IACjC,OAAO,KAAK,CAAC,CAAC;EAClB;;EAEA,OAAO,IAAI,CAAC,CAAC;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}