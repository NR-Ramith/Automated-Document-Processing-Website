{"ast":null,"code":"/**\n * interact.js v1.3.4\n *\n * Copyright (c) 2012-2018 Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n    g.interact = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n      return n[o].exports;\n    }\n    var i = typeof require == \"function\" && require;\n    for (var o = 0; o < r.length; o++) s(r[o]);\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      /*\n       * In a (windowless) server environment this file exports a factory function\n       * that takes the window to use.\n       *\n       *     var interact = require('interact.js')(windowObject);\n       *\n       * See https://github.com/taye/interact.js/issues/187\n       */\n      if (typeof window === 'undefined') {\n        module.exports = function (window) {\n          require('./src/utils/window').init(window);\n          return require('./src/index');\n        };\n      } else {\n        module.exports = require('./src/index');\n      }\n    }, {\n      \"./src/index\": 19,\n      \"./src/utils/window\": 52\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var extend = require('./utils/extend.js');\n      function fireUntilImmediateStopped(event, listeners) {\n        for (var _i = 0; _i < listeners.length; _i++) {\n          var _ref;\n          _ref = listeners[_i];\n          var listener = _ref;\n          if (event.immediatePropagationStopped) {\n            break;\n          }\n          listener(event);\n        }\n      }\n      var Eventable = function () {\n        function Eventable(options) {\n          _classCallCheck(this, Eventable);\n          this.options = extend({}, options || {});\n        }\n        Eventable.prototype.fire = function fire(event) {\n          var listeners = void 0;\n          var onEvent = 'on' + event.type;\n          var global = this.global;\n\n          // Interactable#on() listeners\n          if (listeners = this[event.type]) {\n            fireUntilImmediateStopped(event, listeners);\n          }\n\n          // interactable.onevent listener\n          if (this[onEvent]) {\n            this[onEvent](event);\n          }\n\n          // interact.on() listeners\n          if (!event.propagationStopped && global && (listeners = global[event.type])) {\n            fireUntilImmediateStopped(event, listeners);\n          }\n        };\n        Eventable.prototype.on = function on(eventType, listener) {\n          // if this type of event was never bound\n          if (this[eventType]) {\n            this[eventType].push(listener);\n          } else {\n            this[eventType] = [listener];\n          }\n        };\n        Eventable.prototype.off = function off(eventType, listener) {\n          // if it is an action event type\n          var eventList = this[eventType];\n          var index = eventList ? eventList.indexOf(listener) : -1;\n          if (index !== -1) {\n            eventList.splice(index, 1);\n          }\n          if (eventList && eventList.length === 0 || !listener) {\n            this[eventType] = undefined;\n          }\n        };\n        return Eventable;\n      }();\n      module.exports = Eventable;\n    }, {\n      \"./utils/extend.js\": 41\n    }],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var extend = require('./utils/extend');\n      var getOriginXY = require('./utils/getOriginXY');\n      var defaults = require('./defaultOptions');\n      var signals = require('./utils/Signals').new();\n      var InteractEvent = function () {\n        /** */\n        function InteractEvent(interaction, event, action, phase, element, related) {\n          var preEnd = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n          _classCallCheck(this, InteractEvent);\n          var target = interaction.target;\n          var deltaSource = (target && target.options || defaults).deltaSource;\n          var origin = getOriginXY(target, element, action);\n          var starting = phase === 'start';\n          var ending = phase === 'end';\n          var coords = starting ? interaction.startCoords : interaction.curCoords;\n          var prevEvent = interaction.prevEvent;\n          element = element || interaction.element;\n          var page = extend({}, coords.page);\n          var client = extend({}, coords.client);\n          page.x -= origin.x;\n          page.y -= origin.y;\n          client.x -= origin.x;\n          client.y -= origin.y;\n          this.ctrlKey = event.ctrlKey;\n          this.altKey = event.altKey;\n          this.shiftKey = event.shiftKey;\n          this.metaKey = event.metaKey;\n          this.button = event.button;\n          this.buttons = event.buttons;\n          this.target = element;\n          this.currentTarget = element;\n          this.relatedTarget = related || null;\n          this.preEnd = preEnd;\n          this.type = action + (phase || '');\n          this.interaction = interaction;\n          this.interactable = target;\n          this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1] : prevEvent.t0;\n          var signalArg = {\n            interaction: interaction,\n            event: event,\n            action: action,\n            phase: phase,\n            element: element,\n            related: related,\n            page: page,\n            client: client,\n            coords: coords,\n            starting: starting,\n            ending: ending,\n            deltaSource: deltaSource,\n            iEvent: this\n          };\n          signals.fire('set-xy', signalArg);\n          if (ending) {\n            // use previous coords when ending\n            this.pageX = prevEvent.pageX;\n            this.pageY = prevEvent.pageY;\n            this.clientX = prevEvent.clientX;\n            this.clientY = prevEvent.clientY;\n          } else {\n            this.pageX = page.x;\n            this.pageY = page.y;\n            this.clientX = client.x;\n            this.clientY = client.y;\n          }\n          this.x0 = interaction.startCoords.page.x - origin.x;\n          this.y0 = interaction.startCoords.page.y - origin.y;\n          this.clientX0 = interaction.startCoords.client.x - origin.x;\n          this.clientY0 = interaction.startCoords.client.y - origin.y;\n          signals.fire('set-delta', signalArg);\n          this.timeStamp = coords.timeStamp;\n          this.dt = interaction.pointerDelta.timeStamp;\n          this.duration = this.timeStamp - this.t0;\n\n          // speed and velocity in pixels per second\n          this.speed = interaction.pointerDelta[deltaSource].speed;\n          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n          this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;\n          signals.fire('new', signalArg);\n        }\n        InteractEvent.prototype.getSwipe = function getSwipe() {\n          var interaction = this.interaction;\n          if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n            return null;\n          }\n          var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n          var overlap = 22.5;\n          if (angle < 0) {\n            angle += 360;\n          }\n          var left = 135 - overlap <= angle && angle < 225 + overlap;\n          var up = 225 - overlap <= angle && angle < 315 + overlap;\n          var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n          var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n          return {\n            up: up,\n            down: down,\n            left: left,\n            right: right,\n            angle: angle,\n            speed: interaction.prevEvent.speed,\n            velocity: {\n              x: interaction.prevEvent.velocityX,\n              y: interaction.prevEvent.velocityY\n            }\n          };\n        };\n        InteractEvent.prototype.preventDefault = function preventDefault() {};\n\n        /** */\n\n        InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n          this.immediatePropagationStopped = this.propagationStopped = true;\n        };\n\n        /** */\n\n        InteractEvent.prototype.stopPropagation = function stopPropagation() {\n          this.propagationStopped = true;\n        };\n        return InteractEvent;\n      }();\n      signals.on('set-delta', function (_ref) {\n        var iEvent = _ref.iEvent,\n          interaction = _ref.interaction,\n          starting = _ref.starting,\n          deltaSource = _ref.deltaSource;\n        var prevEvent = starting ? iEvent : interaction.prevEvent;\n        if (deltaSource === 'client') {\n          iEvent.dx = iEvent.clientX - prevEvent.clientX;\n          iEvent.dy = iEvent.clientY - prevEvent.clientY;\n        } else {\n          iEvent.dx = iEvent.pageX - prevEvent.pageX;\n          iEvent.dy = iEvent.pageY - prevEvent.pageY;\n        }\n      });\n      InteractEvent.signals = signals;\n      module.exports = InteractEvent;\n    }, {\n      \"./defaultOptions\": 18,\n      \"./utils/Signals\": 34,\n      \"./utils/extend\": 41,\n      \"./utils/getOriginXY\": 42\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var clone = require('./utils/clone');\n      var is = require('./utils/is');\n      var events = require('./utils/events');\n      var extend = require('./utils/extend');\n      var actions = require('./actions/base');\n      var scope = require('./scope');\n      var Eventable = require('./Eventable');\n      var defaults = require('./defaultOptions');\n      var signals = require('./utils/Signals').new();\n      var _require = require('./utils/domUtils'),\n        getElementRect = _require.getElementRect,\n        nodeContains = _require.nodeContains,\n        trySelector = _require.trySelector,\n        matchesSelector = _require.matchesSelector;\n      var _require2 = require('./utils/window'),\n        getWindow = _require2.getWindow;\n      var _require3 = require('./utils/arr'),\n        contains = _require3.contains;\n      var _require4 = require('./utils/browser'),\n        wheelEvent = _require4.wheelEvent;\n\n      // all set interactables\n\n      scope.interactables = [];\n      var Interactable = function () {\n        /** */\n        function Interactable(target, options) {\n          _classCallCheck(this, Interactable);\n          options = options || {};\n          this.target = target;\n          this.events = new Eventable();\n          this._context = options.context || scope.document;\n          this._win = getWindow(trySelector(target) ? this._context : target);\n          this._doc = this._win.document;\n          signals.fire('new', {\n            target: target,\n            options: options,\n            interactable: this,\n            win: this._win\n          });\n          scope.addDocument(this._doc, this._win);\n          scope.interactables.push(this);\n          this.set(options);\n        }\n        Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n          var onAction = 'on' + action;\n          if (is.function(phases.onstart)) {\n            this.events[onAction + 'start'] = phases.onstart;\n          }\n          if (is.function(phases.onmove)) {\n            this.events[onAction + 'move'] = phases.onmove;\n          }\n          if (is.function(phases.onend)) {\n            this.events[onAction + 'end'] = phases.onend;\n          }\n          if (is.function(phases.oninertiastart)) {\n            this.events[onAction + 'inertiastart'] = phases.oninertiastart;\n          }\n          return this;\n        };\n        Interactable.prototype.setPerAction = function setPerAction(action, options) {\n          // for all the default per-action options\n          for (var option in options) {\n            // if this option exists for this action\n            if (option in defaults[action]) {\n              // if the option in the options arg is an object value\n              if (is.object(options[option])) {\n                // duplicate the object and merge\n                this.options[action][option] = clone(this.options[action][option] || {});\n                extend(this.options[action][option], options[option]);\n                if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n                  this.options[action][option].enabled = options[option].enabled === false ? false : true;\n                }\n              } else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\n                this.options[action][option].enabled = options[option];\n              } else if (options[option] !== undefined) {\n                // or if it's not undefined, do a plain assignment\n                this.options[action][option] = options[option];\n              }\n            }\n          }\n        };\n\n        /**\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using {@link Interactable.rectChecker}.\n         *\n         * @param {Element} [element] The element to measure.\n         * @return {object} The object's bounding rectangle.\n         */\n\n        Interactable.prototype.getRect = function getRect(element) {\n          element = element || this.target;\n          if (is.string(this.target) && !is.element(element)) {\n            element = this._context.querySelector(this.target);\n          }\n          return getElementRect(element);\n        };\n\n        /**\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         * @param {function} [checker] A function which returns this Interactable's\n         * bounding rectangle. See {@link Interactable.getRect}\n         * @return {function | object} The checker function or this Interactable\n         */\n\n        Interactable.prototype.rectChecker = function rectChecker(checker) {\n          if (is.function(checker)) {\n            this.getRect = checker;\n            return this;\n          }\n          if (checker === null) {\n            delete this.options.getRect;\n            return this;\n          }\n          return this.getRect;\n        };\n        Interactable.prototype._backCompatOption = function _backCompatOption(optionName, newValue) {\n          if (trySelector(newValue) || is.object(newValue)) {\n            this.options[optionName] = newValue;\n            for (var _i = 0; _i < actions.names.length; _i++) {\n              var _ref;\n              _ref = actions.names[_i];\n              var action = _ref;\n              this.options[action][optionName] = newValue;\n            }\n            return this;\n          }\n          return this.options[optionName];\n        };\n\n        /**\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         * @param {Element | object | string} [origin] An HTML or SVG Element whose\n         * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n         * or any CSS selector\n         *\n         * @return {object} The current origin or this Interactable\n         */\n\n        Interactable.prototype.origin = function origin(newValue) {\n          return this._backCompatOption('origin', newValue);\n        };\n\n        /**\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         * @param {string} [newValue] Use 'client' if you will be scrolling while\n         * interacting; Use 'page' if you want autoScroll to work\n         * @return {string | object} The current deltaSource or this Interactable\n         */\n\n        Interactable.prototype.deltaSource = function deltaSource(newValue) {\n          if (newValue === 'page' || newValue === 'client') {\n            this.options.deltaSource = newValue;\n            return this;\n          }\n          return this.options.deltaSource;\n        };\n\n        /**\n         * Gets the selector context Node of the Interactable. The default is\n         * `window.document`.\n         *\n         * @return {Node} The context Node of this Interactable\n         */\n\n        Interactable.prototype.context = function context() {\n          return this._context;\n        };\n        Interactable.prototype.inContext = function inContext(element) {\n          return this._context === element.ownerDocument || nodeContains(this._context, element);\n        };\n\n        /**\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n         * Interactable\n         * @return {Interactable} this Interactable\n         */\n\n        Interactable.prototype.fire = function fire(iEvent) {\n          this.events.fire(iEvent);\n          return this;\n        };\n        Interactable.prototype._onOffMultiple = function _onOffMultiple(method, eventType, listener, options) {\n          if (is.string(eventType) && eventType.search(' ') !== -1) {\n            eventType = eventType.trim().split(/ +/);\n          }\n          if (is.array(eventType)) {\n            for (var _i2 = 0; _i2 < eventType.length; _i2++) {\n              var _ref2;\n              _ref2 = eventType[_i2];\n              var type = _ref2;\n              this[method](type, listener, options);\n            }\n            return true;\n          }\n          if (is.object(eventType)) {\n            for (var prop in eventType) {\n              this[method](prop, eventType[prop], listener);\n            }\n            return true;\n          }\n        };\n\n        /**\n         * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n         *\n         * @param {string | array | object} eventType  The types of events to listen\n         * for\n         * @param {function} listener   The function event (s)\n         * @param {object | boolean} [options]    options object or useCapture flag\n         * for addEventListener\n         * @return {object} This Interactable\n         */\n\n        Interactable.prototype.on = function on(eventType, listener, options) {\n          if (this._onOffMultiple('on', eventType, listener, options)) {\n            return this;\n          }\n          if (eventType === 'wheel') {\n            eventType = wheelEvent;\n          }\n          if (contains(Interactable.eventTypes, eventType)) {\n            this.events.on(eventType, listener);\n          }\n          // delegated event for selector\n          else if (is.string(this.target)) {\n            events.addDelegate(this.target, this._context, eventType, listener, options);\n          } else {\n            events.add(this.target, eventType, listener, options);\n          }\n          return this;\n        };\n\n        /**\n         * Removes an InteractEvent, pointerEvent or DOM event listener\n         *\n         * @param {string | array | object} eventType The types of events that were\n         * listened for\n         * @param {function} listener The listener function to be removed\n         * @param {object | boolean} [options] options object or useCapture flag for\n         * removeEventListener\n         * @return {object} This Interactable\n         */\n\n        Interactable.prototype.off = function off(eventType, listener, options) {\n          if (this._onOffMultiple('off', eventType, listener, options)) {\n            return this;\n          }\n          if (eventType === 'wheel') {\n            eventType = wheelEvent;\n          }\n\n          // if it is an action event type\n          if (contains(Interactable.eventTypes, eventType)) {\n            this.events.off(eventType, listener);\n          }\n          // delegated event\n          else if (is.string(this.target)) {\n            events.removeDelegate(this.target, this._context, eventType, listener, options);\n          }\n          // remove listener from this Interatable's element\n          else {\n            events.remove(this.target, eventType, listener, options);\n          }\n          return this;\n        };\n\n        /**\n         * Reset the options of this Interactable\n         *\n         * @param {object} options The new settings to apply\n         * @return {object} This Interactable\n         */\n\n        Interactable.prototype.set = function set(options) {\n          if (!is.object(options)) {\n            options = {};\n          }\n          this.options = clone(defaults.base);\n          var perActions = clone(defaults.perAction);\n          for (var actionName in actions.methodDict) {\n            var methodName = actions.methodDict[actionName];\n            this.options[actionName] = clone(defaults[actionName]);\n            this.setPerAction(actionName, perActions);\n            this[methodName](options[actionName]);\n          }\n          for (var _i3 = 0; _i3 < Interactable.settingsMethods.length; _i3++) {\n            var _ref3;\n            _ref3 = Interactable.settingsMethods[_i3];\n            var setting = _ref3;\n            this.options[setting] = defaults.base[setting];\n            if (setting in options) {\n              this[setting](options[setting]);\n            }\n          }\n          signals.fire('set', {\n            options: options,\n            interactable: this\n          });\n          return this;\n        };\n\n        /**\n         * Remove this interactable from the list of interactables and remove it's\n         * action capabilities and event listeners\n         *\n         * @return {interact}\n         */\n\n        Interactable.prototype.unset = function unset() {\n          events.remove(this.target, 'all');\n          if (is.string(this.target)) {\n            // remove delegated events\n            for (var type in events.delegatedEvents) {\n              var delegated = events.delegatedEvents[type];\n              if (delegated.selectors[0] === this.target && delegated.contexts[0] === this._context) {\n                delegated.selectors.splice(0, 1);\n                delegated.contexts.splice(0, 1);\n                delegated.listeners.splice(0, 1);\n\n                // remove the arrays if they are empty\n                if (!delegated.selectors.length) {\n                  delegated[type] = null;\n                }\n              }\n              events.remove(this._context, type, events.delegateListener);\n              events.remove(this._context, type, events.delegateUseCapture, true);\n            }\n          } else {\n            events.remove(this, 'all');\n          }\n          signals.fire('unset', {\n            interactable: this\n          });\n          scope.interactables.splice(scope.interactables.indexOf(this), 1);\n\n          // Stop related interactions when an Interactable is unset\n          for (var _i4 = 0; _i4 < (scope.interactions || []).length; _i4++) {\n            var _ref4;\n            _ref4 = (scope.interactions || [])[_i4];\n            var interaction = _ref4;\n            if (interaction.target === this && interaction.interacting() && !interaction._ending) {\n              interaction.stop();\n            }\n          }\n          return scope.interact;\n        };\n        return Interactable;\n      }();\n      scope.interactables.indexOfElement = function indexOfElement(target, context) {\n        context = context || scope.document;\n        for (var i = 0; i < this.length; i++) {\n          var interactable = this[i];\n          if (interactable.target === target && interactable._context === context) {\n            return i;\n          }\n        }\n        return -1;\n      };\n      scope.interactables.get = function interactableGet(element, options, dontCheckInContext) {\n        var ret = this[this.indexOfElement(element, options && options.context)];\n        return ret && (is.string(element) || dontCheckInContext || ret.inContext(element)) ? ret : null;\n      };\n      scope.interactables.forEachMatch = function (element, callback) {\n        for (var _i5 = 0; _i5 < this.length; _i5++) {\n          var _ref5;\n          _ref5 = this[_i5];\n          var interactable = _ref5;\n          var ret = void 0;\n          if ((is.string(interactable.target)\n          // target is a selector and the element matches\n          ? is.element(element) && matchesSelector(element, interactable.target) :\n          // target is the element\n          element === interactable.target) &&\n          // the element is in context\n          interactable.inContext(element)) {\n            ret = callback(interactable);\n          }\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      };\n\n      // all interact.js eventTypes\n      Interactable.eventTypes = scope.eventTypes = [];\n      Interactable.signals = signals;\n      Interactable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker'];\n      module.exports = Interactable;\n    }, {\n      \"./Eventable\": 2,\n      \"./actions/base\": 6,\n      \"./defaultOptions\": 18,\n      \"./scope\": 33,\n      \"./utils/Signals\": 34,\n      \"./utils/arr\": 35,\n      \"./utils/browser\": 36,\n      \"./utils/clone\": 37,\n      \"./utils/domUtils\": 39,\n      \"./utils/events\": 40,\n      \"./utils/extend\": 41,\n      \"./utils/is\": 46,\n      \"./utils/window\": 52\n    }],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var scope = require('./scope');\n      var utils = require('./utils');\n      var events = require('./utils/events');\n      var browser = require('./utils/browser');\n      var domObjects = require('./utils/domObjects');\n      var finder = require('./utils/interactionFinder');\n      var signals = require('./utils/Signals').new();\n      var listeners = {};\n      var methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer'];\n\n      // for ignoring browser's simulated mouse events\n      var prevTouchTime = 0;\n\n      // all active and idle interactions\n      scope.interactions = [];\n      var Interaction = function () {\n        /** */\n        function Interaction(_ref) {\n          var pointerType = _ref.pointerType;\n          _classCallCheck(this, Interaction);\n          this.target = null; // current interactable being interacted with\n          this.element = null; // the target element of the interactable\n\n          this.prepared = {\n            // action that's ready to be fired on next move event\n            name: null,\n            axis: null,\n            edges: null\n          };\n\n          // keep track of added pointers\n          this.pointers = [];\n          this.pointerIds = [];\n          this.downTargets = [];\n          this.downTimes = [];\n\n          // Previous native pointer move event coordinates\n          this.prevCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          };\n          // current native pointer move event coordinates\n          this.curCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          };\n\n          // Starting InteractEvent pointer coordinates\n          this.startCoords = {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          };\n\n          // Change in coordinates and time of the pointer\n          this.pointerDelta = {\n            page: {\n              x: 0,\n              y: 0,\n              vx: 0,\n              vy: 0,\n              speed: 0\n            },\n            client: {\n              x: 0,\n              y: 0,\n              vx: 0,\n              vy: 0,\n              speed: 0\n            },\n            timeStamp: 0\n          };\n          this.downEvent = null; // pointerdown/mousedown/touchstart event\n          this.downPointer = {};\n          this._eventTarget = null;\n          this._curEventTarget = null;\n          this.prevEvent = null; // previous action event\n\n          this.pointerIsDown = false;\n          this.pointerWasMoved = false;\n          this._interacting = false;\n          this._ending = false;\n          this.pointerType = pointerType;\n          signals.fire('new', this);\n          scope.interactions.push(this);\n        }\n        Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\n          var pointerIndex = this.updatePointer(pointer, event, true);\n          signals.fire('down', {\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            pointerIndex: pointerIndex,\n            interaction: this\n          });\n        };\n\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable({\n         *     // disable the default drag start by down->move\n         *     manualStart: true\n         *   })\n         *   // start dragging after the user holds the pointer down\n         *   .on('hold', function (event) {\n         *     var interaction = event.interaction;\n         *\n         *     if (!interaction.interacting()) {\n         *       interaction.start({ name: 'drag' },\n         *                         event.interactable,\n         *                         event.currentTarget);\n         *     }\n         * });\n         * ```\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate\n         * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         * @param {object} action   The action to be performed - drag, resize, etc.\n         * @param {Interactable} target  The Interactable to target\n         * @param {Element} element The DOM Element to target\n         * @return {object} interact\n         */\n\n        Interaction.prototype.start = function start(action, target, element) {\n          if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n            return;\n          }\n\n          // if this interaction had been removed after stopping\n          // add it back\n          if (scope.interactions.indexOf(this) === -1) {\n            scope.interactions.push(this);\n          }\n          utils.copyAction(this.prepared, action);\n          this.target = target;\n          this.element = element;\n          signals.fire('action-start', {\n            interaction: this,\n            event: this.downEvent\n          });\n        };\n        Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\n          if (!this.simulation) {\n            this.updatePointer(pointer);\n            utils.setCoords(this.curCoords, this.pointers);\n          }\n          var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n          var dx = void 0;\n          var dy = void 0;\n\n          // register movement greater than pointerMoveTolerance\n          if (this.pointerIsDown && !this.pointerWasMoved) {\n            dx = this.curCoords.client.x - this.startCoords.client.x;\n            dy = this.curCoords.client.y - this.startCoords.client.y;\n            this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n          }\n          var signalArg = {\n            pointer: pointer,\n            pointerIndex: this.getPointerIndex(pointer),\n            event: event,\n            eventTarget: eventTarget,\n            dx: dx,\n            dy: dy,\n            duplicate: duplicateMove,\n            interaction: this,\n            interactingBeforeMove: this.interacting()\n          };\n          if (!duplicateMove) {\n            // set pointer coordinate, time changes and speeds\n            utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n          }\n          signals.fire('move', signalArg);\n          if (!duplicateMove) {\n            // if interacting, fire an 'action-move' signal etc\n            if (this.interacting()) {\n              this.doMove(signalArg);\n            }\n            if (this.pointerWasMoved) {\n              utils.copyCoords(this.prevCoords, this.curCoords);\n            }\n          }\n        };\n\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable(true)\n         *   .on('dragmove', function (event) {\n         *     if (someCondition) {\n         *       // change the snap settings\n         *       event.interactable.draggable({ snap: { targets: [] }});\n         *       // fire another move event with re-calculated snap\n         *       event.interaction.doMove();\n         *     }\n         *   });\n         * ```\n         *\n         * Force a move of the current action at the same coordinates. Useful if\n         * snap/restrict has been changed and you want a movement with the new\n         * settings.\n         */\n\n        Interaction.prototype.doMove = function doMove(signalArg) {\n          signalArg = utils.extend({\n            pointer: this.pointers[0],\n            event: this.prevEvent,\n            eventTarget: this._eventTarget,\n            interaction: this\n          }, signalArg || {});\n          signals.fire('before-action-move', signalArg);\n          if (!this._dontFireMove) {\n            signals.fire('action-move', signalArg);\n          }\n          this._dontFireMove = false;\n        };\n\n        // End interact move events and stop auto-scroll unless simulation is running\n\n        Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n          var pointerIndex = this.getPointerIndex(pointer);\n          signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n            pointer: pointer,\n            pointerIndex: pointerIndex,\n            event: event,\n            eventTarget: eventTarget,\n            curEventTarget: curEventTarget,\n            interaction: this\n          });\n          if (!this.simulation) {\n            this.end(event);\n          }\n          this.pointerIsDown = false;\n          this.removePointer(pointer, event);\n        };\n\n        /**\n         * ```js\n         * interact(target)\n         *   .draggable(true)\n         *   .on('move', function (event) {\n         *     if (event.pageX > 1000) {\n         *       // end the current action\n         *       event.interaction.end();\n         *       // stop all further listeners from being called\n         *       event.stopImmediatePropagation();\n         *     }\n         *   });\n         * ```\n         *\n         * Stop the current action and fire an end event. Inertial movement does\n         * not happen.\n         *\n         * @param {PointerEvent} [event]\n         */\n\n        Interaction.prototype.end = function end(event) {\n          this._ending = true;\n          event = event || this.prevEvent;\n          if (this.interacting()) {\n            signals.fire('action-end', {\n              event: event,\n              interaction: this\n            });\n          }\n          this.stop();\n          this._ending = false;\n        };\n        Interaction.prototype.currentAction = function currentAction() {\n          return this._interacting ? this.prepared.name : null;\n        };\n        Interaction.prototype.interacting = function interacting() {\n          return this._interacting;\n        };\n\n        /** */\n\n        Interaction.prototype.stop = function stop() {\n          signals.fire('stop', {\n            interaction: this\n          });\n          if (this._interacting) {\n            signals.fire('stop-active', {\n              interaction: this\n            });\n            signals.fire('stop-' + this.prepared.name, {\n              interaction: this\n            });\n          }\n          this.target = this.element = null;\n          this._interacting = false;\n          this.prepared.name = this.prevEvent = null;\n        };\n        Interaction.prototype.getPointerIndex = function getPointerIndex(pointer) {\n          // mouse and pen interactions may have only one pointer\n          if (this.pointerType === 'mouse' || this.pointerType === 'pen') {\n            return 0;\n          }\n          return this.pointerIds.indexOf(utils.getPointerId(pointer));\n        };\n        Interaction.prototype.updatePointer = function updatePointer(pointer, event) {\n          var down = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : event && /(down|start)$/i.test(event.type);\n          var id = utils.getPointerId(pointer);\n          var index = this.getPointerIndex(pointer);\n          if (index === -1) {\n            index = this.pointerIds.length;\n            this.pointerIds[index] = id;\n          }\n          if (down) {\n            signals.fire('update-pointer-down', {\n              pointer: pointer,\n              event: event,\n              down: down,\n              pointerId: id,\n              pointerIndex: index,\n              interaction: this\n            });\n          }\n          this.pointers[index] = pointer;\n          return index;\n        };\n        Interaction.prototype.removePointer = function removePointer(pointer, event) {\n          var index = this.getPointerIndex(pointer);\n          if (index === -1) {\n            return;\n          }\n          signals.fire('remove-pointer', {\n            pointer: pointer,\n            event: event,\n            pointerIndex: index,\n            interaction: this\n          });\n          this.pointers.splice(index, 1);\n          this.pointerIds.splice(index, 1);\n          this.downTargets.splice(index, 1);\n          this.downTimes.splice(index, 1);\n        };\n        Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n          this._eventTarget = target;\n          this._curEventTarget = currentTarget;\n        };\n        return Interaction;\n      }();\n      for (var _i = 0; _i < methodNames.length; _i++) {\n        var method = methodNames[_i];\n        listeners[method] = doOnInteractions(method);\n      }\n      function doOnInteractions(method) {\n        return function (event) {\n          var pointerType = utils.getPointerType(event);\n          var _utils$getEventTarget = utils.getEventTargets(event),\n            eventTarget = _utils$getEventTarget[0],\n            curEventTarget = _utils$getEventTarget[1];\n          var matches = []; // [ [pointer, interaction], ...]\n\n          if (browser.supportsTouch && /touch/.test(event.type)) {\n            prevTouchTime = new Date().getTime();\n            for (var _i2 = 0; _i2 < event.changedTouches.length; _i2++) {\n              var _ref2;\n              _ref2 = event.changedTouches[_i2];\n              var changedTouch = _ref2;\n              var pointer = changedTouch;\n              var interaction = finder.search(pointer, event.type, eventTarget);\n              matches.push([pointer, interaction || new Interaction({\n                pointerType: pointerType\n              })]);\n            }\n          } else {\n            var invalidPointer = false;\n            if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n              // ignore mouse events while touch interactions are active\n              for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n                invalidPointer = scope.interactions[i].pointerType !== 'mouse' && scope.interactions[i].pointerIsDown;\n              }\n\n              // try to ignore mouse events that are simulated by the browser\n              // after a touch event\n              invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500\n              // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n              || event.timeStamp === 0;\n            }\n            if (!invalidPointer) {\n              var _interaction = finder.search(event, event.type, eventTarget);\n              if (!_interaction) {\n                _interaction = new Interaction({\n                  pointerType: pointerType\n                });\n              }\n              matches.push([event, _interaction]);\n            }\n          }\n          for (var _i3 = 0; _i3 < matches.length; _i3++) {\n            var _ref3 = matches[_i3];\n            var _pointer = _ref3[0];\n            var _interaction2 = _ref3[1];\n            _interaction2._updateEventTargets(eventTarget, curEventTarget);\n            _interaction2[method](_pointer, event, eventTarget, curEventTarget);\n          }\n        };\n      }\n      function endAll(event) {\n        for (var _i4 = 0; _i4 < scope.interactions.length; _i4++) {\n          var _ref4;\n          _ref4 = scope.interactions[_i4];\n          var interaction = _ref4;\n          interaction.end(event);\n          signals.fire('endall', {\n            event: event,\n            interaction: interaction\n          });\n        }\n      }\n      var docEvents = {/* 'eventType': listenerFunc */};\n      var pEventTypes = browser.pEventTypes;\n      if (domObjects.PointerEvent) {\n        docEvents[pEventTypes.down] = listeners.pointerDown;\n        docEvents[pEventTypes.move] = listeners.pointerMove;\n        docEvents[pEventTypes.up] = listeners.pointerUp;\n        docEvents[pEventTypes.cancel] = listeners.pointerUp;\n      } else {\n        docEvents.mousedown = listeners.pointerDown;\n        docEvents.mousemove = listeners.pointerMove;\n        docEvents.mouseup = listeners.pointerUp;\n        docEvents.touchstart = listeners.pointerDown;\n        docEvents.touchmove = listeners.pointerMove;\n        docEvents.touchend = listeners.pointerUp;\n        docEvents.touchcancel = listeners.pointerUp;\n      }\n      docEvents.blur = endAll;\n      function onDocSignal(_ref5, signalName) {\n        var doc = _ref5.doc;\n        var eventMethod = signalName.indexOf('add') === 0 ? events.add : events.remove;\n\n        // delegate event listener\n        for (var eventType in scope.delegatedEvents) {\n          eventMethod(doc, eventType, events.delegateListener);\n          eventMethod(doc, eventType, events.delegateUseCapture, true);\n        }\n        for (var _eventType in docEvents) {\n          eventMethod(doc, _eventType, docEvents[_eventType], browser.isIOS ? {\n            passive: false\n          } : undefined);\n        }\n      }\n      signals.on('update-pointer-down', function (_ref6) {\n        var interaction = _ref6.interaction,\n          pointer = _ref6.pointer,\n          pointerId = _ref6.pointerId,\n          pointerIndex = _ref6.pointerIndex,\n          event = _ref6.event,\n          eventTarget = _ref6.eventTarget,\n          down = _ref6.down;\n        interaction.pointerIds[pointerIndex] = pointerId;\n        interaction.pointers[pointerIndex] = pointer;\n        if (down) {\n          interaction.pointerIsDown = true;\n        }\n        if (!interaction.interacting()) {\n          utils.setCoords(interaction.startCoords, interaction.pointers);\n          utils.copyCoords(interaction.curCoords, interaction.startCoords);\n          utils.copyCoords(interaction.prevCoords, interaction.startCoords);\n          interaction.downEvent = event;\n          interaction.downTimes[pointerIndex] = interaction.curCoords.timeStamp;\n          interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\n          interaction.pointerWasMoved = false;\n          utils.pointerExtend(interaction.downPointer, pointer);\n        }\n      });\n      scope.signals.on('add-document', onDocSignal);\n      scope.signals.on('remove-document', onDocSignal);\n      Interaction.pointerMoveTolerance = 1;\n      Interaction.doOnInteractions = doOnInteractions;\n      Interaction.endAll = endAll;\n      Interaction.signals = signals;\n      Interaction.docEvents = docEvents;\n      scope.endAllInteractions = endAll;\n      module.exports = Interaction;\n    }, {\n      \"./scope\": 33,\n      \"./utils\": 44,\n      \"./utils/Signals\": 34,\n      \"./utils/browser\": 36,\n      \"./utils/domObjects\": 38,\n      \"./utils/events\": 40,\n      \"./utils/interactionFinder\": 45\n    }],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var Interaction = require('../Interaction');\n      var InteractEvent = require('../InteractEvent');\n      var actions = {\n        firePrepared: firePrepared,\n        names: [],\n        methodDict: {}\n      };\n      Interaction.signals.on('action-start', function (_ref) {\n        var interaction = _ref.interaction,\n          event = _ref.event;\n        interaction._interacting = true;\n        firePrepared(interaction, event, 'start');\n      });\n      Interaction.signals.on('action-move', function (_ref2) {\n        var interaction = _ref2.interaction,\n          event = _ref2.event,\n          preEnd = _ref2.preEnd;\n        firePrepared(interaction, event, 'move', preEnd);\n\n        // if the action was ended in a listener\n        if (!interaction.interacting()) {\n          return false;\n        }\n      });\n      Interaction.signals.on('action-end', function (_ref3) {\n        var interaction = _ref3.interaction,\n          event = _ref3.event;\n        firePrepared(interaction, event, 'end');\n      });\n      function firePrepared(interaction, event, phase, preEnd) {\n        var actionName = interaction.prepared.name;\n        var newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\n        interaction.target.fire(newEvent);\n        interaction.prevEvent = newEvent;\n      }\n      module.exports = actions;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interaction\": 5\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n      var utils = require('../utils');\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n      var Interactable = require('../Interactable');\n      var Interaction = require('../Interaction');\n      var defaultOptions = require('../defaultOptions');\n      var drag = {\n        defaults: {\n          enabled: false,\n          mouseButtons: null,\n          origin: null,\n          snap: null,\n          restrict: null,\n          inertia: null,\n          autoScroll: null,\n          startAxis: 'xy',\n          lockAxis: 'xy'\n        },\n        checker: function checker(pointer, event, interactable) {\n          var dragOptions = interactable.options.drag;\n          return dragOptions.enabled ? {\n            name: 'drag',\n            axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis\n          } : null;\n        },\n        getCursor: function getCursor() {\n          return 'move';\n        }\n      };\n      Interaction.signals.on('before-action-move', function (_ref) {\n        var interaction = _ref.interaction;\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n        var axis = interaction.prepared.axis;\n        if (axis === 'x') {\n          interaction.curCoords.page.y = interaction.startCoords.page.y;\n          interaction.curCoords.client.y = interaction.startCoords.client.y;\n          interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\n          interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n          interaction.pointerDelta.client.vy = 0;\n          interaction.pointerDelta.page.vy = 0;\n        } else if (axis === 'y') {\n          interaction.curCoords.page.x = interaction.startCoords.page.x;\n          interaction.curCoords.client.x = interaction.startCoords.client.x;\n          interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\n          interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n          interaction.pointerDelta.client.vx = 0;\n          interaction.pointerDelta.page.vx = 0;\n        }\n      });\n\n      // dragmove\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n          interaction = _ref2.interaction;\n        if (iEvent.type !== 'dragmove') {\n          return;\n        }\n        var axis = interaction.prepared.axis;\n        if (axis === 'x') {\n          iEvent.pageY = interaction.startCoords.page.y;\n          iEvent.clientY = interaction.startCoords.client.y;\n          iEvent.dy = 0;\n        } else if (axis === 'y') {\n          iEvent.pageX = interaction.startCoords.page.x;\n          iEvent.clientX = interaction.startCoords.client.x;\n          iEvent.dx = 0;\n        }\n      });\n\n      /**\n       * ```js\n       * interact(element).draggable({\n       *     onstart: function (event) {},\n       *     onmove : function (event) {},\n       *     onend  : function (event) {},\n       *\n       *     // the axis in which the first movement must be\n       *     // for the drag sequence to start\n       *     // 'xy' by default - any direction\n       *     startAxis: 'x' || 'y' || 'xy',\n       *\n       *     // 'xy' by default - don't restrict to one axis (move in any direction)\n       *     // 'x' or 'y' to restrict movement to either axis\n       *     // 'start' to restrict movement to the axis the drag started in\n       *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n       *\n       *     // max number of drags that can happen concurrently\n       *     // with elements of this Interactable. Infinity by default\n       *     max: Infinity,\n       *\n       *     // max number of drags that can target the same element+Interactable\n       *     // 1 by default\n       *     maxPerElement: 2\n       * });\n       *\n       * var isDraggable = interact('element').draggable(); // true\n       * ```\n       *\n       * Get or set whether drag actions can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on drag events (object makes the Interactable\n       * draggable)\n       * @return {boolean | Interactable} boolean indicating if this can be the\n       * target of drag events, or this Interctable\n       */\n      Interactable.prototype.draggable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.drag.enabled = options.enabled === false ? false : true;\n          this.setPerAction('drag', options);\n          this.setOnEvents('drag', options);\n          if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n            this.options.drag.lockAxis = options.lockAxis;\n          }\n          if (/^(xy|x|y)$/.test(options.startAxis)) {\n            this.options.drag.startAxis = options.startAxis;\n          }\n          return this;\n        }\n        if (utils.is.bool(options)) {\n          this.options.drag.enabled = options;\n          if (!options) {\n            this.ondragstart = this.ondragstart = this.ondragend = null;\n          }\n          return this;\n        }\n        return this.options.drag;\n      };\n      actions.drag = drag;\n      actions.names.push('drag');\n      utils.merge(Interactable.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'draginertiaresume', 'dragend']);\n      actions.methodDict.drag = 'draggable';\n      defaultOptions.drag = drag.defaults;\n      module.exports = drag;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    8: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n      var utils = require('../utils');\n      var scope = require('../scope');\n      /** @lends module:interact */\n      var interact = require('../interact');\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n      var Interactable = require('../Interactable');\n      var Interaction = require('../Interaction');\n      var defaultOptions = require('../defaultOptions');\n      var drop = {\n        defaults: {\n          enabled: false,\n          accept: null,\n          overlap: 'pointer'\n        }\n      };\n      var dynamicDrop = false;\n      Interaction.signals.on('action-start', function (_ref) {\n        var interaction = _ref.interaction,\n          event = _ref.event;\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n\n        // reset active dropzones\n        interaction.activeDrops.dropzones = [];\n        interaction.activeDrops.elements = [];\n        interaction.activeDrops.rects = [];\n        interaction.dropEvents = null;\n        if (!interaction.dynamicDrop) {\n          setActiveDrops(interaction.activeDrops, interaction.element);\n        }\n        var dragEvent = interaction.prevEvent;\n        var dropEvents = getDropEvents(interaction, event, dragEvent);\n        if (dropEvents.activate) {\n          fireActiveDrops(interaction.activeDrops, dropEvents.activate);\n        }\n      });\n      InteractEvent.signals.on('new', function (_ref2) {\n        var interaction = _ref2.interaction,\n          iEvent = _ref2.iEvent,\n          event = _ref2.event;\n        if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n          return;\n        }\n        var draggableElement = interaction.element;\n        var dragEvent = iEvent;\n        var dropResult = getDrop(dragEvent, event, draggableElement);\n        interaction.dropTarget = dropResult.dropzone;\n        interaction.dropElement = dropResult.element;\n        interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n      });\n      Interaction.signals.on('action-move', function (_ref3) {\n        var interaction = _ref3.interaction;\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n        fireDropEvents(interaction, interaction.dropEvents);\n      });\n      Interaction.signals.on('action-end', function (_ref4) {\n        var interaction = _ref4.interaction;\n        if (interaction.prepared.name === 'drag') {\n          fireDropEvents(interaction, interaction.dropEvents);\n        }\n      });\n      Interaction.signals.on('stop-drag', function (_ref5) {\n        var interaction = _ref5.interaction;\n        interaction.activeDrops = {\n          dropzones: null,\n          elements: null,\n          rects: null\n        };\n        interaction.dropEvents = null;\n      });\n      function collectDrops(activeDrops, element) {\n        var drops = [];\n        var elements = [];\n\n        // collect all dropzones and their elements which qualify for a drop\n        for (var _i = 0; _i < scope.interactables.length; _i++) {\n          var _ref6;\n          _ref6 = scope.interactables[_i];\n          var current = _ref6;\n          if (!current.options.drop.enabled) {\n            continue;\n          }\n          var accept = current.options.drop.accept;\n\n          // test the draggable element against the dropzone's accept setting\n          if (utils.is.element(accept) && accept !== element || utils.is.string(accept) && !utils.matchesSelector(element, accept)) {\n            continue;\n          }\n\n          // query for new elements if necessary\n          var dropElements = utils.is.string(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\n          for (var _i2 = 0; _i2 < dropElements.length; _i2++) {\n            var _ref7;\n            _ref7 = dropElements[_i2];\n            var currentElement = _ref7;\n            if (currentElement !== element) {\n              drops.push(current);\n              elements.push(currentElement);\n            }\n          }\n        }\n        return {\n          elements: elements,\n          dropzones: drops\n        };\n      }\n      function fireActiveDrops(activeDrops, event) {\n        var prevElement = void 0;\n\n        // loop through all active dropzones and trigger event\n        for (var i = 0; i < activeDrops.dropzones.length; i++) {\n          var current = activeDrops.dropzones[i];\n          var currentElement = activeDrops.elements[i];\n\n          // prevent trigger of duplicate events on same element\n          if (currentElement !== prevElement) {\n            // set current element as event target\n            event.target = currentElement;\n            current.fire(event);\n          }\n          prevElement = currentElement;\n        }\n      }\n\n      // Collect a new set of possible drops and save them in activeDrops.\n      // setActiveDrops should always be called when a drag has just started or a\n      // drag event happens while dynamicDrop is true\n      function setActiveDrops(activeDrops, dragElement) {\n        // get dropzones and their elements that could receive the draggable\n        var possibleDrops = collectDrops(activeDrops, dragElement);\n        activeDrops.dropzones = possibleDrops.dropzones;\n        activeDrops.elements = possibleDrops.elements;\n        activeDrops.rects = [];\n        for (var i = 0; i < activeDrops.dropzones.length; i++) {\n          activeDrops.rects[i] = activeDrops.dropzones[i].getRect(activeDrops.elements[i]);\n        }\n      }\n      function getDrop(dragEvent, event, dragElement) {\n        var interaction = dragEvent.interaction;\n        var validDrops = [];\n        if (dynamicDrop) {\n          setActiveDrops(interaction.activeDrops, dragElement);\n        }\n\n        // collect all dropzones and their elements which qualify for a drop\n        for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n          var current = interaction.activeDrops.dropzones[j];\n          var currentElement = interaction.activeDrops.elements[j];\n          var rect = interaction.activeDrops.rects[j];\n          validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n        }\n\n        // get the most appropriate dropzone based on DOM depth and order\n        var dropIndex = utils.indexOfDeepestElement(validDrops);\n        return {\n          dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n          element: interaction.activeDrops.elements[dropIndex] || null\n        };\n      }\n      function getDropEvents(interaction, pointerEvent, dragEvent) {\n        var dropEvents = {\n          enter: null,\n          leave: null,\n          activate: null,\n          deactivate: null,\n          move: null,\n          drop: null\n        };\n        var tmpl = {\n          dragEvent: dragEvent,\n          interaction: interaction,\n          target: interaction.dropElement,\n          dropzone: interaction.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          timeStamp: dragEvent.timeStamp\n        };\n        if (interaction.dropElement !== interaction.prevDropElement) {\n          // if there was a prevDropTarget, create a dragleave event\n          if (interaction.prevDropTarget) {\n            dropEvents.leave = utils.extend({\n              type: 'dragleave'\n            }, tmpl);\n            dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\n            dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n          }\n          // if the dropTarget is not null, create a dragenter event\n          if (interaction.dropTarget) {\n            dropEvents.enter = {\n              dragEvent: dragEvent,\n              interaction: interaction,\n              target: interaction.dropElement,\n              dropzone: interaction.dropTarget,\n              relatedTarget: dragEvent.target,\n              draggable: dragEvent.interactable,\n              timeStamp: dragEvent.timeStamp,\n              type: 'dragenter'\n            };\n            dragEvent.dragEnter = interaction.dropElement;\n            dragEvent.dropzone = interaction.dropTarget;\n          }\n        }\n        if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n          dropEvents.drop = utils.extend({\n            type: 'drop'\n          }, tmpl);\n          dragEvent.dropzone = interaction.dropTarget;\n          dragEvent.relatedTarget = interaction.dropElement;\n        }\n        if (dragEvent.type === 'dragstart') {\n          dropEvents.activate = utils.extend({\n            type: 'dropactivate'\n          }, tmpl);\n          dropEvents.activate.target = null;\n          dropEvents.activate.dropzone = null;\n        }\n        if (dragEvent.type === 'dragend') {\n          dropEvents.deactivate = utils.extend({\n            type: 'dropdeactivate'\n          }, tmpl);\n          dropEvents.deactivate.target = null;\n          dropEvents.deactivate.dropzone = null;\n        }\n        if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n          dropEvents.move = utils.extend({\n            dragmove: dragEvent,\n            type: 'dropmove'\n          }, tmpl);\n          dragEvent.dropzone = interaction.dropTarget;\n        }\n        return dropEvents;\n      }\n      function fireDropEvents(interaction, dropEvents) {\n        var activeDrops = interaction.activeDrops,\n          prevDropTarget = interaction.prevDropTarget,\n          dropTarget = interaction.dropTarget,\n          dropElement = interaction.dropElement;\n        if (dropEvents.leave) {\n          prevDropTarget.fire(dropEvents.leave);\n        }\n        if (dropEvents.move) {\n          dropTarget.fire(dropEvents.move);\n        }\n        if (dropEvents.enter) {\n          dropTarget.fire(dropEvents.enter);\n        }\n        if (dropEvents.drop) {\n          dropTarget.fire(dropEvents.drop);\n        }\n        if (dropEvents.deactivate) {\n          fireActiveDrops(activeDrops, dropEvents.deactivate);\n        }\n        interaction.prevDropTarget = dropTarget;\n        interaction.prevDropElement = dropElement;\n      }\n\n      /**\n       * ```js\n       * interact(target)\n       * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n       *                       event,             // TouchEvent/PointerEvent/MouseEvent\n       *                       dropped,           // bool result of the default checker\n       *                       dropzone,          // dropzone Interactable\n       *                       dropElement,       // dropzone elemnt\n       *                       draggable,         // draggable Interactable\n       *                       draggableElement) {// draggable element\n       *\n       *   return dropped && event.target.hasAttribute('allow-drop');\n       * }\n       * ```\n       *\n       * ```js\n       * interact('.drop').dropzone({\n       *   accept: '.can-drop' || document.getElementById('single-drop'),\n       *   overlap: 'pointer' || 'center' || zeroToOne\n       * }\n       * ```\n       *\n       * Returns or sets whether draggables can be dropped onto this target to\n       * trigger drop events\n       *\n       * Dropzones can receive the following events:\n       *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n       *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n       *  - `dragmove` when a draggable that has entered the dropzone is moved\n       *  - `drop` when a draggable is dropped into this dropzone\n       *\n       * Use the `accept` option to allow only elements that match the given CSS\n       * selector or element. The value can be:\n       *\n       *  - **an Element** - only that element can be dropped into this dropzone.\n       *  - **a string**, - the element being dragged must match it as a CSS selector.\n       *  - **`null`** - accept options is cleared - it accepts any element.\n       *\n       * Use the `overlap` option to set how drops are checked for. The allowed\n       * values are:\n       *\n       *   - `'pointer'`, the pointer must be over the dropzone (default)\n       *   - `'center'`, the draggable element's center must be over the dropzone\n       *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n       *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n       *   over the dropzone\n       *\n       * Use the `checker` option to specify a function to check if a dragged element\n       * is over this Interactable.\n       *\n       * @param {boolean | object | null} [options] The new options to be set.\n       * @return {boolean | Interactable} The current setting or this Interactable\n       */\n      Interactable.prototype.dropzone = function (options) {\n        if (utils.is.object(options)) {\n          this.options.drop.enabled = options.enabled === false ? false : true;\n          if (utils.is.function(options.ondrop)) {\n            this.events.ondrop = options.ondrop;\n          }\n          if (utils.is.function(options.ondropactivate)) {\n            this.events.ondropactivate = options.ondropactivate;\n          }\n          if (utils.is.function(options.ondropdeactivate)) {\n            this.events.ondropdeactivate = options.ondropdeactivate;\n          }\n          if (utils.is.function(options.ondragenter)) {\n            this.events.ondragenter = options.ondragenter;\n          }\n          if (utils.is.function(options.ondragleave)) {\n            this.events.ondragleave = options.ondragleave;\n          }\n          if (utils.is.function(options.ondropmove)) {\n            this.events.ondropmove = options.ondropmove;\n          }\n          if (/^(pointer|center)$/.test(options.overlap)) {\n            this.options.drop.overlap = options.overlap;\n          } else if (utils.is.number(options.overlap)) {\n            this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n          }\n          if ('accept' in options) {\n            this.options.drop.accept = options.accept;\n          }\n          if ('checker' in options) {\n            this.options.drop.checker = options.checker;\n          }\n          return this;\n        }\n        if (utils.is.bool(options)) {\n          this.options.drop.enabled = options;\n          if (!options) {\n            this.ondragenter = this.ondragleave = this.ondrop = this.ondropactivate = this.ondropdeactivate = null;\n          }\n          return this;\n        }\n        return this.options.drop;\n      };\n      Interactable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n        var dropped = false;\n\n        // if the dropzone has no rect (eg. display: none)\n        // call the custom dropChecker or just return false\n        if (!(rect = rect || this.getRect(dropElement))) {\n          return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n        }\n        var dropOverlap = this.options.drop.overlap;\n        if (dropOverlap === 'pointer') {\n          var origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n          var page = utils.getPageXY(dragEvent);\n          page.x += origin.x;\n          page.y += origin.y;\n          var horizontal = page.x > rect.left && page.x < rect.right;\n          var vertical = page.y > rect.top && page.y < rect.bottom;\n          dropped = horizontal && vertical;\n        }\n        var dragRect = draggable.getRect(draggableElement);\n        if (dragRect && dropOverlap === 'center') {\n          var cx = dragRect.left + dragRect.width / 2;\n          var cy = dragRect.top + dragRect.height / 2;\n          dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n        }\n        if (dragRect && utils.is.number(dropOverlap)) {\n          var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n          var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n          dropped = overlapRatio >= dropOverlap;\n        }\n        if (this.options.drop.checker) {\n          dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n        }\n        return dropped;\n      };\n      Interactable.signals.on('unset', function (_ref8) {\n        var interactable = _ref8.interactable;\n        interactable.dropzone(false);\n      });\n      Interactable.settingsMethods.push('dropChecker');\n      Interaction.signals.on('new', function (interaction) {\n        interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n        interaction.dropElement = null; // the element at the time of checking\n        interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n        interaction.prevDropElement = null; // the element at the time of checking\n        interaction.dropEvents = null; // the dropEvents related to the current drag event\n\n        interaction.activeDrops = {\n          dropzones: [],\n          // the dropzones that are mentioned below\n          elements: [],\n          // elements of dropzones that accept the target draggable\n          rects: [] // the rects of the elements mentioned above\n        };\n      });\n\n      Interaction.signals.on('stop', function (_ref9) {\n        var interaction = _ref9.interaction;\n        interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n      });\n\n      /**\n       * Returns or sets whether the dimensions of dropzone elements are calculated\n       * on every dragmove or only on dragstart for the default dropChecker\n       *\n       * @param {boolean} [newValue] True to check on each move. False to check only\n       * before start\n       * @return {boolean | interact} The current setting or interact\n       */\n      interact.dynamicDrop = function (newValue) {\n        if (utils.is.bool(newValue)) {\n          //if (dragging && dynamicDrop !== newValue && !newValue) {\n          //calcRects(dropzones);\n          //}\n\n          dynamicDrop = newValue;\n          return interact;\n        }\n        return dynamicDrop;\n      };\n      utils.merge(Interactable.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\n      actions.methodDict.drop = 'dropzone';\n      defaultOptions.drop = drop.defaults;\n      module.exports = drop;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../scope\": 33,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    9: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n      var utils = require('../utils');\n      var InteractEvent = require('../InteractEvent');\n      var Interactable = require('../Interactable');\n      var Interaction = require('../Interaction');\n      var defaultOptions = require('../defaultOptions');\n      var gesture = {\n        defaults: {\n          enabled: false,\n          origin: null,\n          restrict: null\n        },\n        checker: function checker(pointer, event, interactable, element, interaction) {\n          if (interaction.pointerIds.length >= 2) {\n            return {\n              name: 'gesture'\n            };\n          }\n          return null;\n        },\n        getCursor: function getCursor() {\n          return '';\n        }\n      };\n      InteractEvent.signals.on('new', function (_ref) {\n        var iEvent = _ref.iEvent,\n          interaction = _ref.interaction;\n        if (iEvent.type !== 'gesturestart') {\n          return;\n        }\n        iEvent.ds = 0;\n        interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n        interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n        interaction.gesture.scale = 1;\n      });\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n          interaction = _ref2.interaction;\n        if (iEvent.type !== 'gesturemove') {\n          return;\n        }\n        iEvent.ds = iEvent.scale - interaction.gesture.scale;\n        interaction.target.fire(iEvent);\n        interaction.gesture.prevAngle = iEvent.angle;\n        interaction.gesture.prevDistance = iEvent.distance;\n        if (iEvent.scale !== Infinity && iEvent.scale !== null && iEvent.scale !== undefined && !isNaN(iEvent.scale)) {\n          interaction.gesture.scale = iEvent.scale;\n        }\n      });\n\n      /**\n       * ```js\n       * interact(element).gesturable({\n       *     onstart: function (event) {},\n       *     onmove : function (event) {},\n       *     onend  : function (event) {},\n       *\n       *     // limit multiple gestures.\n       *     // See the explanation in {@link Interactable.draggable} example\n       *     max: Infinity,\n       *     maxPerElement: 1,\n       * });\n       *\n       * var isGestureable = interact(element).gesturable();\n       * ```\n       *\n       * Gets or sets whether multitouch gestures can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on gesture events (makes the Interactable gesturable)\n       * @return {boolean | Interactable} A boolean indicating if this can be the\n       * target of gesture events, or this Interactable\n       */\n      Interactable.prototype.gesturable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.gesture.enabled = options.enabled === false ? false : true;\n          this.setPerAction('gesture', options);\n          this.setOnEvents('gesture', options);\n          return this;\n        }\n        if (utils.is.bool(options)) {\n          this.options.gesture.enabled = options;\n          if (!options) {\n            this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n          }\n          return this;\n        }\n        return this.options.gesture;\n      };\n      InteractEvent.signals.on('set-delta', function (_ref3) {\n        var interaction = _ref3.interaction,\n          iEvent = _ref3.iEvent,\n          action = _ref3.action,\n          event = _ref3.event,\n          starting = _ref3.starting,\n          ending = _ref3.ending,\n          deltaSource = _ref3.deltaSource;\n        if (action !== 'gesture') {\n          return;\n        }\n        var pointers = interaction.pointers;\n        iEvent.touches = [pointers[0], pointers[1]];\n        if (starting) {\n          iEvent.distance = utils.touchDistance(pointers, deltaSource);\n          iEvent.box = utils.touchBBox(pointers);\n          iEvent.scale = 1;\n          iEvent.ds = 0;\n          iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n          iEvent.da = 0;\n        } else if (ending || event instanceof InteractEvent) {\n          iEvent.distance = interaction.prevEvent.distance;\n          iEvent.box = interaction.prevEvent.box;\n          iEvent.scale = interaction.prevEvent.scale;\n          iEvent.ds = iEvent.scale - 1;\n          iEvent.angle = interaction.prevEvent.angle;\n          iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n        } else {\n          iEvent.distance = utils.touchDistance(pointers, deltaSource);\n          iEvent.box = utils.touchBBox(pointers);\n          iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n          iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n          iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n          iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n        }\n      });\n      Interaction.signals.on('new', function (interaction) {\n        interaction.gesture = {\n          start: {\n            x: 0,\n            y: 0\n          },\n          startDistance: 0,\n          // distance between two touches of touchStart\n          prevDistance: 0,\n          distance: 0,\n          scale: 1,\n          // gesture.distance / gesture.startDistance\n\n          startAngle: 0,\n          // angle of line joining two touches\n          prevAngle: 0 // angle of the previous gesture event\n        };\n      });\n\n      actions.gesture = gesture;\n      actions.names.push('gesture');\n      utils.merge(Interactable.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);\n      actions.methodDict.gesture = 'gesturable';\n      defaultOptions.gesture = gesture.defaults;\n      module.exports = gesture;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 6\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      var actions = require('./base');\n      var utils = require('../utils');\n      var browser = require('../utils/browser');\n      var InteractEvent = require('../InteractEvent');\n      /** @lends Interactable */\n      var Interactable = require('../Interactable');\n      var Interaction = require('../Interaction');\n      var defaultOptions = require('../defaultOptions');\n\n      // Less Precision with touch input\n      var defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n      var resize = {\n        defaults: {\n          enabled: false,\n          mouseButtons: null,\n          origin: null,\n          snap: null,\n          restrict: null,\n          inertia: null,\n          autoScroll: null,\n          square: false,\n          preserveAspectRatio: false,\n          axis: 'xy',\n          // use default margin\n          margin: NaN,\n          // object with props left, right, top, bottom which are\n          // true/false values to resize when the pointer is over that edge,\n          // CSS selectors to match the handles for each direction\n          // or the Elements for each handle\n          edges: null,\n          // a value of 'none' will limit the resize rect to a minimum of 0x0\n          // 'negate' will alow the rect to have negative width/height\n          // 'reposition' will keep the width/height positive by swapping\n          // the top and bottom edges and/or swapping the left and right edges\n          invert: 'none'\n        },\n        checker: function checker(pointer, event, interactable, element, interaction, rect) {\n          if (!rect) {\n            return null;\n          }\n          var page = utils.extend({}, interaction.curCoords.page);\n          var options = interactable.options;\n          if (options.resize.enabled) {\n            var resizeOptions = options.resize;\n            var resizeEdges = {\n              left: false,\n              right: false,\n              top: false,\n              bottom: false\n            };\n\n            // if using resize.edges\n            if (utils.is.object(resizeOptions.edges)) {\n              for (var edge in resizeEdges) {\n                resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || defaultMargin);\n              }\n              resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n              resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n              if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n                return {\n                  name: 'resize',\n                  edges: resizeEdges\n                };\n              }\n            } else {\n              var right = options.resize.axis !== 'y' && page.x > rect.right - defaultMargin;\n              var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - defaultMargin;\n              if (right || bottom) {\n                return {\n                  name: 'resize',\n                  axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n                };\n              }\n            }\n          }\n          return null;\n        },\n        cursors: browser.isIe9 ? {\n          x: 'e-resize',\n          y: 's-resize',\n          xy: 'se-resize',\n          top: 'n-resize',\n          left: 'w-resize',\n          bottom: 's-resize',\n          right: 'e-resize',\n          topleft: 'se-resize',\n          bottomright: 'se-resize',\n          topright: 'ne-resize',\n          bottomleft: 'ne-resize'\n        } : {\n          x: 'ew-resize',\n          y: 'ns-resize',\n          xy: 'nwse-resize',\n          top: 'ns-resize',\n          left: 'ew-resize',\n          bottom: 'ns-resize',\n          right: 'ew-resize',\n          topleft: 'nwse-resize',\n          bottomright: 'nwse-resize',\n          topright: 'nesw-resize',\n          bottomleft: 'nesw-resize'\n        },\n        getCursor: function getCursor(action) {\n          if (action.axis) {\n            return resize.cursors[action.name + action.axis];\n          } else if (action.edges) {\n            var cursorKey = '';\n            var edgeNames = ['top', 'bottom', 'left', 'right'];\n            for (var i = 0; i < 4; i++) {\n              if (action.edges[edgeNames[i]]) {\n                cursorKey += edgeNames[i];\n              }\n            }\n            return resize.cursors[cursorKey];\n          }\n        }\n      };\n\n      // resizestart\n      InteractEvent.signals.on('new', function (_ref) {\n        var iEvent = _ref.iEvent,\n          interaction = _ref.interaction;\n        if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n          return;\n        }\n        var startRect = interaction.target.getRect(interaction.element);\n        var resizeOptions = interaction.target.options.resize;\n\n        /*\n         * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n         * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n         * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n         * on the active edges and the edge being interacted with.\n         */\n        if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n          var linkedEdges = utils.extend({}, interaction.prepared.edges);\n          linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n          linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n          linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n          linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n          interaction.prepared._linkedEdges = linkedEdges;\n        } else {\n          interaction.prepared._linkedEdges = null;\n        }\n\n        // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n        if (resizeOptions.preserveAspectRatio) {\n          interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n        }\n        interaction.resizeRects = {\n          start: startRect,\n          current: utils.extend({}, startRect),\n          inverted: utils.extend({}, startRect),\n          previous: utils.extend({}, startRect),\n          delta: {\n            left: 0,\n            right: 0,\n            width: 0,\n            top: 0,\n            bottom: 0,\n            height: 0\n          }\n        };\n        iEvent.rect = interaction.resizeRects.inverted;\n        iEvent.deltaRect = interaction.resizeRects.delta;\n      });\n\n      // resizemove\n      InteractEvent.signals.on('new', function (_ref2) {\n        var iEvent = _ref2.iEvent,\n          phase = _ref2.phase,\n          interaction = _ref2.interaction;\n        if (phase !== 'move' || !interaction.prepared.edges) {\n          return;\n        }\n        var resizeOptions = interaction.target.options.resize;\n        var invert = resizeOptions.invert;\n        var invertible = invert === 'reposition' || invert === 'negate';\n        var edges = interaction.prepared.edges;\n        var start = interaction.resizeRects.start;\n        var current = interaction.resizeRects.current;\n        var inverted = interaction.resizeRects.inverted;\n        var delta = interaction.resizeRects.delta;\n        var previous = utils.extend(interaction.resizeRects.previous, inverted);\n        var originalEdges = edges;\n        var dx = iEvent.dx;\n        var dy = iEvent.dy;\n        if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n          // `resize.preserveAspectRatio` takes precedence over `resize.square`\n          var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\n          edges = interaction.prepared._linkedEdges;\n          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n            dy = -dx / startAspectRatio;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx / startAspectRatio;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy * startAspectRatio;\n          }\n        }\n\n        // update the 'current' rect without modifications\n        if (edges.top) {\n          current.top += dy;\n        }\n        if (edges.bottom) {\n          current.bottom += dy;\n        }\n        if (edges.left) {\n          current.left += dx;\n        }\n        if (edges.right) {\n          current.right += dx;\n        }\n        if (invertible) {\n          // if invertible, copy the current rect\n          utils.extend(inverted, current);\n          if (invert === 'reposition') {\n            // swap edge values if necessary to keep width/height positive\n            var swap = void 0;\n            if (inverted.top > inverted.bottom) {\n              swap = inverted.top;\n              inverted.top = inverted.bottom;\n              inverted.bottom = swap;\n            }\n            if (inverted.left > inverted.right) {\n              swap = inverted.left;\n              inverted.left = inverted.right;\n              inverted.right = swap;\n            }\n          }\n        } else {\n          // if not invertible, restrict to minimum of 0x0 rect\n          inverted.top = Math.min(current.top, start.bottom);\n          inverted.bottom = Math.max(current.bottom, start.top);\n          inverted.left = Math.min(current.left, start.right);\n          inverted.right = Math.max(current.right, start.left);\n        }\n        inverted.width = inverted.right - inverted.left;\n        inverted.height = inverted.bottom - inverted.top;\n        for (var edge in inverted) {\n          delta[edge] = inverted[edge] - previous[edge];\n        }\n        iEvent.edges = interaction.prepared.edges;\n        iEvent.rect = inverted;\n        iEvent.deltaRect = delta;\n      });\n\n      /**\n       * ```js\n       * interact(element).resizable({\n       *   onstart: function (event) {},\n       *   onmove : function (event) {},\n       *   onend  : function (event) {},\n       *\n       *   edges: {\n       *     top   : true,       // Use pointer coords to check for resize.\n       *     left  : false,      // Disable resizing from left edge.\n       *     bottom: '.resize-s',// Resize if pointer target matches selector\n       *     right : handleEl    // Resize if pointer target is the given Element\n       *   },\n       *\n       *     // Width and height can be adjusted independently. When `true`, width and\n       *     // height are adjusted at a 1:1 ratio.\n       *     square: false,\n       *\n       *     // Width and height can be adjusted independently. When `true`, width and\n       *     // height maintain the aspect ratio they had when resizing started.\n       *     preserveAspectRatio: false,\n       *\n       *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n       *   // 'negate' will allow the rect to have negative width/height\n       *   // 'reposition' will keep the width/height positive by swapping\n       *   // the top and bottom edges and/or swapping the left and right edges\n       *   invert: 'none' || 'negate' || 'reposition'\n       *\n       *   // limit multiple resizes.\n       *   // See the explanation in the {@link Interactable.draggable} example\n       *   max: Infinity,\n       *   maxPerElement: 1,\n       * });\n       *\n       * var isResizeable = interact(element).resizable();\n       * ```\n       *\n       * Gets or sets whether resize actions can be performed on the target\n       *\n       * @param {boolean | object} [options] true/false or An object with event\n       * listeners to be fired on resize events (object makes the Interactable\n       * resizable)\n       * @return {boolean | Interactable} A boolean indicating if this can be the\n       * target of resize elements, or this Interactable\n       */\n      Interactable.prototype.resizable = function (options) {\n        if (utils.is.object(options)) {\n          this.options.resize.enabled = options.enabled === false ? false : true;\n          this.setPerAction('resize', options);\n          this.setOnEvents('resize', options);\n          if (/^x$|^y$|^xy$/.test(options.axis)) {\n            this.options.resize.axis = options.axis;\n          } else if (options.axis === null) {\n            this.options.resize.axis = defaultOptions.resize.axis;\n          }\n          if (utils.is.bool(options.preserveAspectRatio)) {\n            this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n          } else if (utils.is.bool(options.square)) {\n            this.options.resize.square = options.square;\n          }\n          return this;\n        }\n        if (utils.is.bool(options)) {\n          this.options.resize.enabled = options;\n          if (!options) {\n            this.onresizestart = this.onresizestart = this.onresizeend = null;\n          }\n          return this;\n        }\n        return this.options.resize;\n      };\n      function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) {\n          return false;\n        }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n          // if dimensions are negative, \"switch\" edges\n          var width = utils.is.number(rect.width) ? rect.width : rect.right - rect.left;\n          var height = utils.is.number(rect.height) ? rect.height : rect.bottom - rect.top;\n          if (width < 0) {\n            if (name === 'left') {\n              name = 'right';\n            } else if (name === 'right') {\n              name = 'left';\n            }\n          }\n          if (height < 0) {\n            if (name === 'top') {\n              name = 'bottom';\n            } else if (name === 'bottom') {\n              name = 'top';\n            }\n          }\n          if (name === 'left') {\n            return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n          }\n          if (name === 'top') {\n            return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n          }\n          if (name === 'right') {\n            return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n          }\n          if (name === 'bottom') {\n            return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n          }\n        }\n\n        // the remaining checks require an element\n        if (!utils.is.element(element)) {\n          return false;\n        }\n        return utils.is.element(value)\n        // the value is an element to use as a resize handle\n        ? value === element\n        // otherwise check if element matches value as selector\n        : utils.matchesUpTo(element, value, interactableElement);\n      }\n      Interaction.signals.on('new', function (interaction) {\n        interaction.resizeAxes = 'xy';\n      });\n      InteractEvent.signals.on('set-delta', function (_ref3) {\n        var interaction = _ref3.interaction,\n          iEvent = _ref3.iEvent,\n          action = _ref3.action;\n        if (action !== 'resize' || !interaction.resizeAxes) {\n          return;\n        }\n        var options = interaction.target.options;\n        if (options.resize.square) {\n          if (interaction.resizeAxes === 'y') {\n            iEvent.dx = iEvent.dy;\n          } else {\n            iEvent.dy = iEvent.dx;\n          }\n          iEvent.axes = 'xy';\n        } else {\n          iEvent.axes = interaction.resizeAxes;\n          if (interaction.resizeAxes === 'x') {\n            iEvent.dy = 0;\n          } else if (interaction.resizeAxes === 'y') {\n            iEvent.dx = 0;\n          }\n        }\n      });\n      actions.resize = resize;\n      actions.names.push('resize');\n      utils.merge(Interactable.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeinertiaresume', 'resizeend']);\n      actions.methodDict.resize = 'resizable';\n      defaultOptions.resize = resize.defaults;\n      module.exports = resize;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/browser\": 36,\n      \"./base\": 6\n    }],\n    11: [function (require, module, exports) {\n      'use strict';\n\n      var raf = require('./utils/raf');\n      var getWindow = require('./utils/window').getWindow;\n      var is = require('./utils/is');\n      var domUtils = require('./utils/domUtils');\n      var Interaction = require('./Interaction');\n      var defaultOptions = require('./defaultOptions');\n      var autoScroll = {\n        defaults: {\n          enabled: false,\n          container: null,\n          // the item that is scrolled (Window or HTMLElement)\n          margin: 60,\n          speed: 300 // the scroll speed in pixels per second\n        },\n\n        interaction: null,\n        i: null,\n        // the handle returned by window.setInterval\n        x: 0,\n        y: 0,\n        // Direction each pulse is to scroll in\n\n        isScrolling: false,\n        prevTime: 0,\n        start: function start(interaction) {\n          autoScroll.isScrolling = true;\n          raf.cancel(autoScroll.i);\n          autoScroll.interaction = interaction;\n          autoScroll.prevTime = new Date().getTime();\n          autoScroll.i = raf.request(autoScroll.scroll);\n        },\n        stop: function stop() {\n          autoScroll.isScrolling = false;\n          raf.cancel(autoScroll.i);\n        },\n        // scroll the window by the values in scroll.x/y\n        scroll: function scroll() {\n          var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n          var container = options.container || getWindow(autoScroll.interaction.element);\n          var now = new Date().getTime();\n          // change in time in seconds\n          var dt = (now - autoScroll.prevTime) / 1000;\n          // displacement\n          var s = options.speed * dt;\n          if (s >= 1) {\n            if (is.window(container)) {\n              container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n            } else if (container) {\n              container.scrollLeft += autoScroll.x * s;\n              container.scrollTop += autoScroll.y * s;\n            }\n            autoScroll.prevTime = now;\n          }\n          if (autoScroll.isScrolling) {\n            raf.cancel(autoScroll.i);\n            autoScroll.i = raf.request(autoScroll.scroll);\n          }\n        },\n        check: function check(interactable, actionName) {\n          var options = interactable.options;\n          return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n        },\n        onInteractionMove: function onInteractionMove(_ref) {\n          var interaction = _ref.interaction,\n            pointer = _ref.pointer;\n          if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n            return;\n          }\n          if (interaction.simulation) {\n            autoScroll.x = autoScroll.y = 0;\n            return;\n          }\n          var top = void 0;\n          var right = void 0;\n          var bottom = void 0;\n          var left = void 0;\n          var options = interaction.target.options[interaction.prepared.name].autoScroll;\n          var container = options.container || getWindow(interaction.element);\n          if (is.window(container)) {\n            left = pointer.clientX < autoScroll.margin;\n            top = pointer.clientY < autoScroll.margin;\n            right = pointer.clientX > container.innerWidth - autoScroll.margin;\n            bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n          } else {\n            var rect = domUtils.getElementClientRect(container);\n            left = pointer.clientX < rect.left + autoScroll.margin;\n            top = pointer.clientY < rect.top + autoScroll.margin;\n            right = pointer.clientX > rect.right - autoScroll.margin;\n            bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n          }\n          autoScroll.x = right ? 1 : left ? -1 : 0;\n          autoScroll.y = bottom ? 1 : top ? -1 : 0;\n          if (!autoScroll.isScrolling) {\n            // set the autoScroll properties to those of the target\n            autoScroll.margin = options.margin;\n            autoScroll.speed = options.speed;\n            autoScroll.start(interaction);\n          }\n        }\n      };\n      Interaction.signals.on('stop-active', function () {\n        autoScroll.stop();\n      });\n      Interaction.signals.on('action-move', autoScroll.onInteractionMove);\n      defaultOptions.perAction.autoScroll = autoScroll.defaults;\n      module.exports = autoScroll;\n    }, {\n      \"./Interaction\": 5,\n      \"./defaultOptions\": 18,\n      \"./utils/domUtils\": 39,\n      \"./utils/is\": 46,\n      \"./utils/raf\": 50,\n      \"./utils/window\": 52\n    }],\n    12: [function (require, module, exports) {\n      'use strict';\n\n      /** @lends Interactable */\n      var Interactable = require('../Interactable');\n      var actions = require('../actions/base');\n      var is = require('../utils/is');\n      var domUtils = require('../utils/domUtils');\n      var _require = require('../utils'),\n        warnOnce = _require.warnOnce;\n      Interactable.prototype.getAction = function (pointer, event, interaction, element) {\n        var action = this.defaultActionChecker(pointer, event, interaction, element);\n        if (this.options.actionChecker) {\n          return this.options.actionChecker(pointer, event, action, this, element, interaction);\n        }\n        return action;\n      };\n\n      /**\n       * ```js\n       * interact(element, { ignoreFrom: document.getElementById('no-action') });\n       * // or\n       * interact(element).ignoreFrom('input, textarea, a');\n       * ```\n       * @deprecated\n       * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n       * of it's parents match the given CSS selector or Element, no\n       * drag/resize/gesture is started.\n       *\n       * Don't use this method. Instead set the `ignoreFrom` option for each action\n       * or for `pointerEvents`\n       *\n       * @example\n       * interact(targett)\n       *   .draggable({\n       *     ignoreFrom: 'input, textarea, a[href]'',\n       *   })\n       *   .pointerEvents({\n       *     ignoreFrom: '[no-pointer]',\n       *   });\n       *\n       * @param {string | Element | null} [newValue] a CSS selector string, an\n       * Element or `null` to not ignore any elements\n       * @return {string | Element | object} The current ignoreFrom value or this\n       * Interactable\n       */\n      Interactable.prototype.ignoreFrom = warnOnce(function (newValue) {\n        return this._backCompatOption('ignoreFrom', newValue);\n      }, 'Interactable.ignoreForm() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');\n\n      /**\n       * ```js\n       *\n       * @deprecated\n       * A drag/resize/gesture is started only If the target of the `mousedown`,\n       * `pointerdown` or `touchstart` event or any of it's parents match the given\n       * CSS selector or Element.\n       *\n       * Don't use this method. Instead set the `allowFrom` option for each action\n       * or for `pointerEvents`\n       *\n       * @example\n       * interact(targett)\n       *   .resizable({\n       *     allowFrom: '.resize-handle',\n       *   .pointerEvents({\n       *     allowFrom: '.handle',,\n       *   });\n       *\n       * @param {string | Element | null} [newValue] a CSS selector string, an\n       * Element or `null` to allow from any element\n       * @return {string | Element | object} The current allowFrom value or this\n       * Interactable\n       */\n      Interactable.prototype.allowFrom = warnOnce(function (newValue) {\n        return this._backCompatOption('allowFrom', newValue);\n      }, 'Interactable.allowForm() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');\n      Interactable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n        if (!ignoreFrom || !is.element(element)) {\n          return false;\n        }\n        if (is.string(ignoreFrom)) {\n          return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n        } else if (is.element(ignoreFrom)) {\n          return domUtils.nodeContains(ignoreFrom, element);\n        }\n        return false;\n      };\n      Interactable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n        if (!allowFrom) {\n          return true;\n        }\n        if (!is.element(element)) {\n          return false;\n        }\n        if (is.string(allowFrom)) {\n          return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n        } else if (is.element(allowFrom)) {\n          return domUtils.nodeContains(allowFrom, element);\n        }\n        return false;\n      };\n      Interactable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n        return !this.testIgnore(options.ignoreFrom, interactableElement, eventTarget) && this.testAllow(options.allowFrom, interactableElement, eventTarget);\n      };\n\n      /**\n       * ```js\n       * interact('.resize-drag')\n       *   .resizable(true)\n       *   .draggable(true)\n       *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n       *\n       *   if (interact.matchesSelector(event.target, '.drag-handle') {\n       *     // force drag with handle target\n       *     action.name = drag;\n       *   }\n       *   else {\n       *     // resize from the top and right edges\n       *     action.name  = 'resize';\n       *     action.edges = { top: true, right: true };\n       *   }\n       *\n       *   return action;\n       * });\n       * ```\n       *\n       * Gets or sets the function used to check action to be performed on\n       * pointerDown\n       *\n       * @param {function | null} [checker] A function which takes a pointer event,\n       * defaultAction string, interactable, element and interaction as parameters\n       * and returns an object with name property 'drag' 'resize' or 'gesture' and\n       * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n       * props.\n       * @return {Function | Interactable} The checker function or this Interactable\n       */\n      Interactable.prototype.actionChecker = function (checker) {\n        if (is.function(checker)) {\n          this.options.actionChecker = checker;\n          return this;\n        }\n        if (checker === null) {\n          delete this.options.actionChecker;\n          return this;\n        }\n        return this.options.actionChecker;\n      };\n\n      /**\n       * Returns or sets whether the the cursor should be changed depending on the\n       * action that would be performed if the mouse were pressed and dragged.\n       *\n       * @param {boolean} [newValue]\n       * @return {boolean | Interactable} The current setting or this Interactable\n       */\n      Interactable.prototype.styleCursor = function (newValue) {\n        if (is.bool(newValue)) {\n          this.options.styleCursor = newValue;\n          return this;\n        }\n        if (newValue === null) {\n          delete this.options.styleCursor;\n          return this;\n        }\n        return this.options.styleCursor;\n      };\n      Interactable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n        var rect = this.getRect(element);\n        var buttons = event.buttons || {\n          0: 1,\n          1: 4,\n          3: 8,\n          4: 16\n        }[event.button];\n        var action = null;\n        for (var _i = 0; _i < actions.names.length; _i++) {\n          var _ref;\n          _ref = actions.names[_i];\n          var actionName = _ref;\n\n          // check mouseButton setting if the pointer is down\n          if (interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & this.options[actionName].mouseButtons) === 0) {\n            continue;\n          }\n          action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n          if (action) {\n            return action;\n          }\n        }\n      };\n    }, {\n      \"../Interactable\": 4,\n      \"../actions/base\": 6,\n      \"../utils\": 44,\n      \"../utils/domUtils\": 39,\n      \"../utils/is\": 46\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n\n      var interact = require('../interact');\n      var Interactable = require('../Interactable');\n      var Interaction = require('../Interaction');\n      var actions = require('../actions/base');\n      var defaultOptions = require('../defaultOptions');\n      var scope = require('../scope');\n      var utils = require('../utils');\n      var signals = require('../utils/Signals').new();\n      require('./InteractableMethods');\n      var autoStart = {\n        signals: signals,\n        withinInteractionLimit: withinInteractionLimit,\n        // Allow this many interactions to happen simultaneously\n        maxInteractions: Infinity,\n        defaults: {\n          perAction: {\n            manualStart: false,\n            max: Infinity,\n            maxPerElement: 1,\n            allowFrom: null,\n            ignoreFrom: null,\n            // only allow left button by default\n            // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n            mouseButtons: 1\n          }\n        },\n        setActionDefaults: function setActionDefaults(action) {\n          utils.extend(action.defaults, autoStart.defaults.perAction);\n        },\n        validateAction: validateAction\n      };\n\n      // set cursor style on mousedown\n      Interaction.signals.on('down', function (_ref) {\n        var interaction = _ref.interaction,\n          pointer = _ref.pointer,\n          event = _ref.event,\n          eventTarget = _ref.eventTarget;\n        if (interaction.interacting()) {\n          return;\n        }\n        var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n        prepare(interaction, actionInfo);\n      });\n\n      // set cursor style on mousemove\n      Interaction.signals.on('move', function (_ref2) {\n        var interaction = _ref2.interaction,\n          pointer = _ref2.pointer,\n          event = _ref2.event,\n          eventTarget = _ref2.eventTarget;\n        if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) {\n          return;\n        }\n        var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n        prepare(interaction, actionInfo);\n      });\n      Interaction.signals.on('move', function (arg) {\n        var interaction = arg.interaction,\n          event = arg.event;\n        if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {\n          return;\n        }\n        signals.fire('before-start', arg);\n        var target = interaction.target;\n        if (interaction.prepared.name && target) {\n          // check manualStart and interaction limit\n          if (target.options[interaction.prepared.name].manualStart || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n            interaction.stop(event);\n          } else {\n            interaction.start(interaction.prepared, target, interaction.element);\n          }\n        }\n      });\n\n      // Check if the current target supports the action.\n      // If so, return the validated action. Otherwise, return null\n      function validateAction(action, interactable, element, eventTarget) {\n        if (utils.is.object(action) && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action)) {\n          return action;\n        }\n        return null;\n      }\n      function validateSelector(interaction, pointer, event, matches, matchElements, eventTarget) {\n        for (var i = 0, len = matches.length; i < len; i++) {\n          var match = matches[i];\n          var matchElement = matchElements[i];\n          var action = validateAction(match.getAction(pointer, event, interaction, matchElement), match, matchElement, eventTarget);\n          if (action) {\n            return {\n              action: action,\n              target: match,\n              element: matchElement\n            };\n          }\n        }\n        return {};\n      }\n      function getActionInfo(interaction, pointer, event, eventTarget) {\n        var matches = [];\n        var matchElements = [];\n        var element = eventTarget;\n        function pushMatches(interactable) {\n          matches.push(interactable);\n          matchElements.push(element);\n        }\n        while (utils.is.element(element)) {\n          matches = [];\n          matchElements = [];\n          scope.interactables.forEachMatch(element, pushMatches);\n          var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n          if (actionInfo.action && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n            return actionInfo;\n          }\n          element = utils.parentNode(element);\n        }\n        return {};\n      }\n      function prepare(interaction, _ref3) {\n        var action = _ref3.action,\n          target = _ref3.target,\n          element = _ref3.element;\n        action = action || {};\n        if (interaction.target && interaction.target.options.styleCursor) {\n          interaction.target._doc.documentElement.style.cursor = '';\n        }\n        interaction.target = target;\n        interaction.element = element;\n        utils.copyAction(interaction.prepared, action);\n        if (target && target.options.styleCursor) {\n          var cursor = action ? actions[action.name].getCursor(action) : '';\n          interaction.target._doc.documentElement.style.cursor = cursor;\n        }\n        signals.fire('prepared', {\n          interaction: interaction\n        });\n      }\n      Interaction.signals.on('stop', function (_ref4) {\n        var interaction = _ref4.interaction;\n        var target = interaction.target;\n        if (target && target.options.styleCursor) {\n          target._doc.documentElement.style.cursor = '';\n        }\n      });\n      function withinInteractionLimit(interactable, element, action) {\n        var options = interactable.options;\n        var maxActions = options[action.name].max;\n        var maxPerElement = options[action.name].maxPerElement;\n        var activeInteractions = 0;\n        var targetCount = 0;\n        var targetElementCount = 0;\n\n        // no actions if any of these values == 0\n        if (!(maxActions && maxPerElement && autoStart.maxInteractions)) {\n          return;\n        }\n        for (var _i = 0; _i < scope.interactions.length; _i++) {\n          var _ref5;\n          _ref5 = scope.interactions[_i];\n          var interaction = _ref5;\n          var otherAction = interaction.prepared.name;\n          if (!interaction.interacting()) {\n            continue;\n          }\n          activeInteractions++;\n          if (activeInteractions >= autoStart.maxInteractions) {\n            return false;\n          }\n          if (interaction.target !== interactable) {\n            continue;\n          }\n          targetCount += otherAction === action.name | 0;\n          if (targetCount >= maxActions) {\n            return false;\n          }\n          if (interaction.element === element) {\n            targetElementCount++;\n            if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n              return false;\n            }\n          }\n        }\n        return autoStart.maxInteractions > 0;\n      }\n\n      /**\n       * Returns or sets the maximum number of concurrent interactions allowed.  By\n       * default only 1 interaction is allowed at a time (for backwards\n       * compatibility). To allow multiple interactions on the same Interactables and\n       * elements, you need to enable it in the draggable, resizable and gesturable\n       * `'max'` and `'maxPerElement'` options.\n       *\n       * @alias module:interact.maxInteractions\n       *\n       * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n       */\n      interact.maxInteractions = function (newValue) {\n        if (utils.is.number(newValue)) {\n          autoStart.maxInteractions = newValue;\n          return interact;\n        }\n        return autoStart.maxInteractions;\n      };\n      Interactable.settingsMethods.push('styleCursor');\n      Interactable.settingsMethods.push('actionChecker');\n      Interactable.settingsMethods.push('ignoreFrom');\n      Interactable.settingsMethods.push('allowFrom');\n      defaultOptions.base.actionChecker = null;\n      defaultOptions.base.styleCursor = true;\n      utils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n      module.exports = autoStart;\n    }, {\n      \"../Interactable\": 4,\n      \"../Interaction\": 5,\n      \"../actions/base\": 6,\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../scope\": 33,\n      \"../utils\": 44,\n      \"../utils/Signals\": 34,\n      \"./InteractableMethods\": 12\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n\n      var autoStart = require('./base');\n      var scope = require('../scope');\n      var is = require('../utils/is');\n      var _require = require('../utils/domUtils'),\n        parentNode = _require.parentNode;\n      autoStart.setActionDefaults(require('../actions/drag'));\n      autoStart.signals.on('before-start', function (_ref) {\n        var interaction = _ref.interaction,\n          eventTarget = _ref.eventTarget,\n          dx = _ref.dx,\n          dy = _ref.dy;\n        if (interaction.prepared.name !== 'drag') {\n          return;\n        }\n\n        // check if a drag is in the correct axis\n        var absX = Math.abs(dx);\n        var absY = Math.abs(dy);\n        var targetOptions = interaction.target.options.drag;\n        var startAxis = targetOptions.startAxis;\n        var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n        interaction.prepared.axis = targetOptions.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n        : targetOptions.lockAxis;\n\n        // if the movement isn't in the startAxis of the interactable\n        if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n          // cancel the prepared action\n          interaction.prepared.name = null;\n\n          // then try to get a drag from another ineractable\n          var element = eventTarget;\n          var getDraggable = function getDraggable(interactable) {\n            if (interactable === interaction.target) {\n              return;\n            }\n            var options = interaction.target.options.drag;\n            if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n              var action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n              if (action && action.name === 'drag' && checkStartAxis(currentAxis, interactable) && autoStart.validateAction(action, interactable, element, eventTarget)) {\n                return interactable;\n              }\n            }\n          };\n\n          // check all interactables\n          while (is.element(element)) {\n            var interactable = scope.interactables.forEachMatch(element, getDraggable);\n            if (interactable) {\n              interaction.prepared.name = 'drag';\n              interaction.target = interactable;\n              interaction.element = element;\n              break;\n            }\n            element = parentNode(element);\n          }\n        }\n      });\n      function checkStartAxis(startAxis, interactable) {\n        if (!interactable) {\n          return false;\n        }\n        var thisAxis = interactable.options.drag.startAxis;\n        return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\n      }\n    }, {\n      \"../actions/drag\": 7,\n      \"../scope\": 33,\n      \"../utils/domUtils\": 39,\n      \"../utils/is\": 46,\n      \"./base\": 13\n    }],\n    15: [function (require, module, exports) {\n      'use strict';\n\n      require('./base').setActionDefaults(require('../actions/gesture'));\n    }, {\n      \"../actions/gesture\": 9,\n      \"./base\": 13\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      var autoStart = require('./base');\n      var Interaction = require('../Interaction');\n      autoStart.defaults.perAction.hold = 0;\n      autoStart.defaults.perAction.delay = 0;\n      Interaction.signals.on('new', function (interaction) {\n        interaction.autoStartHoldTimer = null;\n      });\n      autoStart.signals.on('prepared', function (_ref) {\n        var interaction = _ref.interaction;\n        var hold = getHoldDuration(interaction);\n        if (hold > 0) {\n          interaction.autoStartHoldTimer = setTimeout(function () {\n            interaction.start(interaction.prepared, interaction.target, interaction.element);\n          }, hold);\n        }\n      });\n      Interaction.signals.on('move', function (_ref2) {\n        var interaction = _ref2.interaction,\n          duplicate = _ref2.duplicate;\n        if (interaction.pointerWasMoved && !duplicate) {\n          clearTimeout(interaction.autoStartHoldTimer);\n        }\n      });\n\n      // prevent regular down->move autoStart\n      autoStart.signals.on('before-start', function (_ref3) {\n        var interaction = _ref3.interaction;\n        var hold = getHoldDuration(interaction);\n        if (hold > 0) {\n          interaction.prepared.name = null;\n        }\n      });\n      function getHoldDuration(interaction) {\n        var actionName = interaction.prepared && interaction.prepared.name;\n        if (!actionName) {\n          return null;\n        }\n        var options = interaction.target.options;\n        return options[actionName].hold || options[actionName].delay;\n      }\n      module.exports = {\n        getHoldDuration: getHoldDuration\n      };\n    }, {\n      \"../Interaction\": 5,\n      \"./base\": 13\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      require('./base').setActionDefaults(require('../actions/resize'));\n    }, {\n      \"../actions/resize\": 10,\n      \"./base\": 13\n    }],\n    18: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        base: {\n          accept: null,\n          preventDefault: 'auto',\n          deltaSource: 'page'\n        },\n        perAction: {\n          origin: {\n            x: 0,\n            y: 0\n          },\n          inertia: {\n            enabled: false,\n            resistance: 10,\n            // the lambda in exponential decay\n            minSpeed: 100,\n            // target speed must be above this for inertia to start\n            endSpeed: 10,\n            // the speed at which inertia is slow enough to stop\n            allowResume: true,\n            // allow resuming an action in inertia phase\n            smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n          }\n        }\n      };\n    }, {}],\n    19: [function (require, module, exports) {\n      'use strict';\n\n      /* browser entry point */\n\n      // inertia\n      require('./inertia');\n\n      // modifiers\n      require('./modifiers/snap');\n      require('./modifiers/restrict');\n\n      // pointerEvents\n      require('./pointerEvents/base');\n      require('./pointerEvents/holdRepeat');\n      require('./pointerEvents/interactableTargets');\n\n      // autoStart hold\n      require('./autoStart/hold');\n\n      // actions\n      require('./actions/gesture');\n      require('./actions/resize');\n      require('./actions/drag');\n      require('./actions/drop');\n\n      // load these modifiers after resize is loaded\n      require('./modifiers/snapSize');\n      require('./modifiers/restrictEdges');\n      require('./modifiers/restrictSize');\n\n      // autoStart actions\n      require('./autoStart/gesture');\n      require('./autoStart/resize');\n      require('./autoStart/drag');\n\n      // Interactable preventDefault setting\n      require('./interactablePreventDefault.js');\n\n      // autoScroll\n      require('./autoScroll');\n\n      // export interact\n      module.exports = require('./interact');\n    }, {\n      \"./actions/drag\": 7,\n      \"./actions/drop\": 8,\n      \"./actions/gesture\": 9,\n      \"./actions/resize\": 10,\n      \"./autoScroll\": 11,\n      \"./autoStart/drag\": 14,\n      \"./autoStart/gesture\": 15,\n      \"./autoStart/hold\": 16,\n      \"./autoStart/resize\": 17,\n      \"./inertia\": 20,\n      \"./interact\": 21,\n      \"./interactablePreventDefault.js\": 22,\n      \"./modifiers/restrict\": 24,\n      \"./modifiers/restrictEdges\": 25,\n      \"./modifiers/restrictSize\": 26,\n      \"./modifiers/snap\": 27,\n      \"./modifiers/snapSize\": 28,\n      \"./pointerEvents/base\": 30,\n      \"./pointerEvents/holdRepeat\": 31,\n      \"./pointerEvents/interactableTargets\": 32\n    }],\n    20: [function (require, module, exports) {\n      'use strict';\n\n      var InteractEvent = require('./InteractEvent');\n      var Interaction = require('./Interaction');\n      var modifiers = require('./modifiers/base');\n      var utils = require('./utils');\n      var animationFrame = require('./utils/raf');\n      Interaction.signals.on('new', function (interaction) {\n        interaction.inertiaStatus = {\n          active: false,\n          smoothEnd: false,\n          allowResume: false,\n          startEvent: null,\n          upCoords: {},\n          xe: 0,\n          ye: 0,\n          sx: 0,\n          sy: 0,\n          t0: 0,\n          vx0: 0,\n          vys: 0,\n          duration: 0,\n          lambda_v0: 0,\n          one_ve_v0: 0,\n          i: null\n        };\n        interaction.boundInertiaFrame = function () {\n          return inertiaFrame.apply(interaction);\n        };\n        interaction.boundSmoothEndFrame = function () {\n          return smoothEndFrame.apply(interaction);\n        };\n      });\n      Interaction.signals.on('down', function (_ref) {\n        var interaction = _ref.interaction,\n          event = _ref.event,\n          pointer = _ref.pointer,\n          eventTarget = _ref.eventTarget;\n        var status = interaction.inertiaStatus;\n\n        // Check if the down event hits the current inertia target\n        if (status.active) {\n          var element = eventTarget;\n\n          // climb up the DOM tree from the event target\n          while (utils.is.element(element)) {\n            // if interaction element is the current inertia target element\n            if (element === interaction.element) {\n              // stop inertia\n              animationFrame.cancel(status.i);\n              status.active = false;\n              interaction.simulation = null;\n\n              // update pointers to the down event's coordinates\n              interaction.updatePointer(pointer);\n              utils.setCoords(interaction.curCoords, interaction.pointers);\n\n              // fire appropriate signals\n              var signalArg = {\n                interaction: interaction\n              };\n              Interaction.signals.fire('before-action-move', signalArg);\n              Interaction.signals.fire('action-resume', signalArg);\n\n              // fire a reume event\n              var resumeEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiaresume', interaction.element);\n              interaction.target.fire(resumeEvent);\n              interaction.prevEvent = resumeEvent;\n              modifiers.resetStatuses(interaction.modifierStatuses);\n              utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n              break;\n            }\n            element = utils.parentNode(element);\n          }\n        }\n      });\n      Interaction.signals.on('up', function (_ref2) {\n        var interaction = _ref2.interaction,\n          event = _ref2.event;\n        var status = interaction.inertiaStatus;\n        if (!interaction.interacting() || status.active) {\n          return;\n        }\n        var target = interaction.target;\n        var options = target && target.options;\n        var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n        var now = new Date().getTime();\n        var statuses = {};\n        var page = utils.extend({}, interaction.curCoords.page);\n        var pointerSpeed = interaction.pointerDelta.client.speed;\n        var smoothEnd = false;\n        var modifierResult = void 0;\n\n        // check if inertia should be started\n        var inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\n        var inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n        var modifierArg = {\n          interaction: interaction,\n          pageCoords: page,\n          statuses: statuses,\n          preEnd: true,\n          requireEndOnly: true\n        };\n\n        // smoothEnd\n        if (inertiaPossible && !inertia) {\n          modifiers.resetStatuses(statuses);\n          modifierResult = modifiers.setAll(modifierArg);\n          if (modifierResult.shouldMove && modifierResult.locked) {\n            smoothEnd = true;\n          }\n        }\n        if (!(inertia || smoothEnd)) {\n          return;\n        }\n        utils.copyCoords(status.upCoords, interaction.curCoords);\n        interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n        status.t0 = now;\n        status.active = true;\n        status.allowResume = inertiaOptions.allowResume;\n        interaction.simulation = status;\n        target.fire(status.startEvent);\n        if (inertia) {\n          status.vx0 = interaction.pointerDelta.client.vx;\n          status.vy0 = interaction.pointerDelta.client.vy;\n          status.v0 = pointerSpeed;\n          calcInertia(interaction, status);\n          utils.extend(page, interaction.curCoords.page);\n          page.x += status.xe;\n          page.y += status.ye;\n          modifiers.resetStatuses(statuses);\n          modifierResult = modifiers.setAll(modifierArg);\n          status.modifiedXe += modifierResult.dx;\n          status.modifiedYe += modifierResult.dy;\n          status.i = animationFrame.request(interaction.boundInertiaFrame);\n        } else {\n          status.smoothEnd = true;\n          status.xe = modifierResult.dx;\n          status.ye = modifierResult.dy;\n          status.sx = status.sy = 0;\n          status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n        }\n      });\n      Interaction.signals.on('stop-active', function (_ref3) {\n        var interaction = _ref3.interaction;\n        var status = interaction.inertiaStatus;\n        if (status.active) {\n          animationFrame.cancel(status.i);\n          status.active = false;\n          interaction.simulation = null;\n        }\n      });\n      function calcInertia(interaction, status) {\n        var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n        var lambda = inertiaOptions.resistance;\n        var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n        status.x0 = interaction.prevEvent.pageX;\n        status.y0 = interaction.prevEvent.pageY;\n        status.t0 = status.startEvent.timeStamp / 1000;\n        status.sx = status.sy = 0;\n        status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n        status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n        status.te = inertiaDur;\n        status.lambda_v0 = lambda / status.v0;\n        status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n      }\n      function inertiaFrame() {\n        updateInertiaCoords(this);\n        utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n        var status = this.inertiaStatus;\n        var options = this.target.options[this.prepared.name].inertia;\n        var lambda = options.resistance;\n        var t = new Date().getTime() / 1000 - status.t0;\n        if (t < status.te) {\n          var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n          if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n            status.sx = status.xe * progress;\n            status.sy = status.ye * progress;\n          } else {\n            var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\n            status.sx = quadPoint.x;\n            status.sy = quadPoint.y;\n          }\n          this.doMove();\n          status.i = animationFrame.request(this.boundInertiaFrame);\n        } else {\n          status.sx = status.modifiedXe;\n          status.sy = status.modifiedYe;\n          this.doMove();\n          this.end(status.startEvent);\n          status.active = false;\n          this.simulation = null;\n        }\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n      function smoothEndFrame() {\n        updateInertiaCoords(this);\n        var status = this.inertiaStatus;\n        var t = new Date().getTime() - status.t0;\n        var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n        if (t < duration) {\n          status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n          status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n          this.pointerMove(status.startEvent, status.startEvent);\n          status.i = animationFrame.request(this.boundSmoothEndFrame);\n        } else {\n          status.sx = status.xe;\n          status.sy = status.ye;\n          this.pointerMove(status.startEvent, status.startEvent);\n          this.end(status.startEvent);\n          status.smoothEnd = status.active = false;\n          this.simulation = null;\n        }\n      }\n      function updateInertiaCoords(interaction) {\n        var status = interaction.inertiaStatus;\n\n        // return if inertia isn't running\n        if (!status.active) {\n          return;\n        }\n        var pageUp = status.upCoords.page;\n        var clientUp = status.upCoords.client;\n        utils.setCoords(interaction.curCoords, [{\n          pageX: pageUp.x + status.sx,\n          pageY: pageUp.y + status.sy,\n          clientX: clientUp.x + status.sx,\n          clientY: clientUp.y + status.sy\n        }]);\n      }\n    }, {\n      \"./InteractEvent\": 3,\n      \"./Interaction\": 5,\n      \"./modifiers/base\": 23,\n      \"./utils\": 44,\n      \"./utils/raf\": 50\n    }],\n    21: [function (require, module, exports) {\n      'use strict';\n\n      /** @module interact */\n      var browser = require('./utils/browser');\n      var events = require('./utils/events');\n      var utils = require('./utils');\n      var scope = require('./scope');\n      var Interactable = require('./Interactable');\n      var Interaction = require('./Interaction');\n      var globalEvents = {};\n\n      /**\n       * ```js\n       * interact('#draggable').draggable(true);\n       *\n       * var rectables = interact('rect');\n       * rectables\n       *   .gesturable(true)\n       *   .on('gesturemove', function (event) {\n       *       // ...\n       *   });\n       * ```\n       *\n       * The methods of this variable can be used to set elements as interactables\n       * and also to change various default settings.\n       *\n       * Calling it as a function and passing an element or a valid CSS selector\n       * string returns an Interactable object which has various methods to configure\n       * it.\n       *\n       * @global\n       *\n       * @param {Element | string} element The HTML or SVG Element to interact with\n       * or CSS selector\n       * @return {Interactable}\n       */\n      function interact(element, options) {\n        var interactable = scope.interactables.get(element, options);\n        if (!interactable) {\n          interactable = new Interactable(element, options);\n          interactable.events.global = globalEvents;\n        }\n        return interactable;\n      }\n\n      /**\n       * Check if an element or selector has been set with the {@link interact}\n       * function\n       *\n       * @alias module:interact.isSet\n       *\n       * @param {Element} element The Element being searched for\n       * @return {boolean} Indicates if the element or CSS selector was previously\n       * passed to interact\n      */\n      interact.isSet = function (element, options) {\n        return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n      };\n\n      /**\n       * Add a global listener for an InteractEvent or adds a DOM event to `document`\n       *\n       * @alias module:interact.on\n       *\n       * @param {string | array | object} type The types of events to listen for\n       * @param {function} listener The function event (s)\n       * @param {object | boolean} [options] object or useCapture flag for\n       * addEventListener\n       * @return {object} interact\n       */\n      interact.on = function (type, listener, options) {\n        if (utils.is.string(type) && type.search(' ') !== -1) {\n          type = type.trim().split(/ +/);\n        }\n        if (utils.is.array(type)) {\n          for (var _i = 0; _i < type.length; _i++) {\n            var _ref;\n            _ref = type[_i];\n            var eventType = _ref;\n            interact.on(eventType, listener, options);\n          }\n          return interact;\n        }\n        if (utils.is.object(type)) {\n          for (var prop in type) {\n            interact.on(prop, type[prop], listener);\n          }\n          return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (utils.contains(Interactable.eventTypes, type)) {\n          // if this type of event was never bound\n          if (!globalEvents[type]) {\n            globalEvents[type] = [listener];\n          } else {\n            globalEvents[type].push(listener);\n          }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n          events.add(scope.document, type, listener, {\n            options: options\n          });\n        }\n        return interact;\n      };\n\n      /**\n       * Removes a global InteractEvent listener or DOM event from `document`\n       *\n       * @alias module:interact.off\n       *\n       * @param {string | array | object} type The types of events that were listened\n       * for\n       * @param {function} listener The listener function to be removed\n       * @param {object | boolean} options [options] object or useCapture flag for\n       * removeEventListener\n       * @return {object} interact\n       */\n      interact.off = function (type, listener, options) {\n        if (utils.is.string(type) && type.search(' ') !== -1) {\n          type = type.trim().split(/ +/);\n        }\n        if (utils.is.array(type)) {\n          for (var _i2 = 0; _i2 < type.length; _i2++) {\n            var _ref2;\n            _ref2 = type[_i2];\n            var eventType = _ref2;\n            interact.off(eventType, listener, options);\n          }\n          return interact;\n        }\n        if (utils.is.object(type)) {\n          for (var prop in type) {\n            interact.off(prop, type[prop], listener);\n          }\n          return interact;\n        }\n        if (!utils.contains(Interactable.eventTypes, type)) {\n          events.remove(scope.document, type, listener, options);\n        } else {\n          var index = void 0;\n          if (type in globalEvents && (index = globalEvents[type].indexOf(listener)) !== -1) {\n            globalEvents[type].splice(index, 1);\n          }\n        }\n        return interact;\n      };\n\n      /**\n       * Returns an object which exposes internal data\n      \n       * @alias module:interact.debug\n       *\n       * @return {object} An object with properties that outline the current state\n       * and expose internal functions and variables\n       */\n      interact.debug = function () {\n        return scope;\n      };\n\n      // expose the functions used to calculate multi-touch properties\n      interact.getPointerAverage = utils.pointerAverage;\n      interact.getTouchBBox = utils.touchBBox;\n      interact.getTouchDistance = utils.touchDistance;\n      interact.getTouchAngle = utils.touchAngle;\n      interact.getElementRect = utils.getElementRect;\n      interact.getElementClientRect = utils.getElementClientRect;\n      interact.matchesSelector = utils.matchesSelector;\n      interact.closest = utils.closest;\n\n      /**\n       * @alias module:interact.supportsTouch\n       *\n       * @return {boolean} Whether or not the browser supports touch input\n       */\n      interact.supportsTouch = function () {\n        return browser.supportsTouch;\n      };\n\n      /**\n       * @alias module:interact.supportsPointerEvent\n       *\n       * @return {boolean} Whether or not the browser supports PointerEvents\n       */\n      interact.supportsPointerEvent = function () {\n        return browser.supportsPointerEvent;\n      };\n\n      /**\n       * Cancels all interactions (end events are not fired)\n       *\n       * @alias module:interact.stop\n       *\n       * @param {Event} event An event on which to call preventDefault()\n       * @return {object} interact\n       */\n      interact.stop = function (event) {\n        for (var i = scope.interactions.length - 1; i >= 0; i--) {\n          scope.interactions[i].stop(event);\n        }\n        return interact;\n      };\n\n      /**\n       * Returns or sets the distance the pointer must be moved before an action\n       * sequence occurs. This also affects tolerance for tap events.\n       *\n       * @alias module:interact.pointerMoveTolerance\n       *\n       * @param {number} [newValue] The movement from the start position must be greater than this value\n       * @return {interact | number}\n       */\n      interact.pointerMoveTolerance = function (newValue) {\n        if (utils.is.number(newValue)) {\n          Interaction.pointerMoveTolerance = newValue;\n          return interact;\n        }\n        return Interaction.pointerMoveTolerance;\n      };\n      interact.addDocument = scope.addDocument;\n      interact.removeDocument = scope.removeDocument;\n      scope.interact = interact;\n      module.exports = interact;\n    }, {\n      \"./Interactable\": 4,\n      \"./Interaction\": 5,\n      \"./scope\": 33,\n      \"./utils\": 44,\n      \"./utils/browser\": 36,\n      \"./utils/events\": 40\n    }],\n    22: [function (require, module, exports) {\n      'use strict';\n\n      var Interactable = require('./Interactable');\n      var Interaction = require('./Interaction');\n      var scope = require('./scope');\n      var is = require('./utils/is');\n      var events = require('./utils/events');\n      var browser = require('./utils/browser');\n      var _require = require('./utils/domUtils'),\n        nodeContains = _require.nodeContains,\n        matchesSelector = _require.matchesSelector;\n\n      /**\n       * Returns or sets whether to prevent the browser's default behaviour in\n       * response to pointer events. Can be set to:\n       *  - `'always'` to always prevent\n       *  - `'never'` to never prevent\n       *  - `'auto'` to let interact.js try to determine what would be best\n       *\n       * @param {string} [newValue] `true`, `false` or `'auto'`\n       * @return {string | Interactable} The current setting or this Interactable\n       */\n\n      Interactable.prototype.preventDefault = function (newValue) {\n        if (/^(always|never|auto)$/.test(newValue)) {\n          this.options.preventDefault = newValue;\n          return this;\n        }\n        if (is.bool(newValue)) {\n          this.options.preventDefault = newValue ? 'always' : 'never';\n          return this;\n        }\n        return this.options.preventDefault;\n      };\n      Interactable.prototype.checkAndPreventDefault = function (event) {\n        var setting = this.options.preventDefault;\n        if (setting === 'never') {\n          return;\n        }\n        if (setting === 'always') {\n          event.preventDefault();\n          return;\n        }\n\n        // setting === 'auto'\n\n        // don't preventDefault of touch{start,move} events if the browser supports passive\n        // events listeners. CSS touch-action and user-selecct should be used instead\n        if (events.supportsPassive && /^touch(start|move)$/.test(event.type) && !browser.isIOS) {\n          return;\n        }\n\n        // don't preventDefault of pointerdown events\n        if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n          return;\n        }\n\n        // don't preventDefault on editable elements\n        if (is.element(event.target) && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n          return;\n        }\n        event.preventDefault();\n      };\n      function onInteractionEvent(_ref) {\n        var interaction = _ref.interaction,\n          event = _ref.event;\n        if (interaction.target) {\n          interaction.target.checkAndPreventDefault(event);\n        }\n      }\n      var _arr = ['down', 'move', 'up', 'cancel'];\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var eventSignal = _arr[_i];\n        Interaction.signals.on(eventSignal, onInteractionEvent);\n      }\n\n      // prevent native HTML5 drag on interact.js target elements\n      Interaction.docEvents.dragstart = function preventNativeDrag(event) {\n        for (var _i2 = 0; _i2 < scope.interactions.length; _i2++) {\n          var _ref2;\n          _ref2 = scope.interactions[_i2];\n          var interaction = _ref2;\n          if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n            interaction.target.checkAndPreventDefault(event);\n            return;\n          }\n        }\n      };\n    }, {\n      \"./Interactable\": 4,\n      \"./Interaction\": 5,\n      \"./scope\": 33,\n      \"./utils/browser\": 36,\n      \"./utils/domUtils\": 39,\n      \"./utils/events\": 40,\n      \"./utils/is\": 46\n    }],\n    23: [function (require, module, exports) {\n      'use strict';\n\n      var InteractEvent = require('../InteractEvent');\n      var Interaction = require('../Interaction');\n      var extend = require('../utils/extend');\n      var modifiers = {\n        names: [],\n        setOffsets: function setOffsets(arg) {\n          var interaction = arg.interaction,\n            page = arg.pageCoords;\n          var target = interaction.target,\n            element = interaction.element,\n            startOffset = interaction.startOffset;\n          var rect = target.getRect(element);\n          if (rect) {\n            startOffset.left = page.x - rect.left;\n            startOffset.top = page.y - rect.top;\n            startOffset.right = rect.right - page.x;\n            startOffset.bottom = rect.bottom - page.y;\n            if (!('width' in rect)) {\n              rect.width = rect.right - rect.left;\n            }\n            if (!('height' in rect)) {\n              rect.height = rect.bottom - rect.top;\n            }\n          } else {\n            startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n          }\n          arg.rect = rect;\n          arg.interactable = target;\n          arg.element = element;\n          for (var _i = 0; _i < modifiers.names.length; _i++) {\n            var _ref;\n            _ref = modifiers.names[_i];\n            var modifierName = _ref;\n            arg.options = target.options[interaction.prepared.name][modifierName];\n            if (!arg.options) {\n              continue;\n            }\n            interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\n          }\n        },\n        setAll: function setAll(arg) {\n          var interaction = arg.interaction,\n            statuses = arg.statuses,\n            preEnd = arg.preEnd,\n            requireEndOnly = arg.requireEndOnly;\n          var result = {\n            dx: 0,\n            dy: 0,\n            changed: false,\n            locked: false,\n            shouldMove: true\n          };\n          arg.modifiedCoords = extend({}, arg.pageCoords);\n          for (var _i2 = 0; _i2 < modifiers.names.length; _i2++) {\n            var _ref2;\n            _ref2 = modifiers.names[_i2];\n            var modifierName = _ref2;\n            var modifier = modifiers[modifierName];\n            var options = interaction.target.options[interaction.prepared.name][modifierName];\n            if (!shouldDo(options, preEnd, requireEndOnly)) {\n              continue;\n            }\n            arg.status = arg.status = statuses[modifierName];\n            arg.options = options;\n            arg.offset = arg.interaction.modifierOffsets[modifierName];\n            modifier.set(arg);\n            if (arg.status.locked) {\n              arg.modifiedCoords.x += arg.status.dx;\n              arg.modifiedCoords.y += arg.status.dy;\n              result.dx += arg.status.dx;\n              result.dy += arg.status.dy;\n              result.locked = true;\n            }\n          }\n\n          // a move should be fired if:\n          //  - there are no modifiers enabled,\n          //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n          //  - the locked coords have changed since the last pointer move\n          result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n          return result;\n        },\n        resetStatuses: function resetStatuses(statuses) {\n          for (var _i3 = 0; _i3 < modifiers.names.length; _i3++) {\n            var _ref3;\n            _ref3 = modifiers.names[_i3];\n            var modifierName = _ref3;\n            var status = statuses[modifierName] || {};\n            status.dx = status.dy = 0;\n            status.modifiedX = status.modifiedY = NaN;\n            status.locked = false;\n            status.changed = true;\n            statuses[modifierName] = status;\n          }\n          return statuses;\n        },\n        start: function start(_ref4, signalName) {\n          var interaction = _ref4.interaction;\n          var arg = {\n            interaction: interaction,\n            pageCoords: (signalName === 'action-resume' ? interaction.curCoords : interaction.startCoords).page,\n            startOffset: interaction.startOffset,\n            statuses: interaction.modifierStatuses,\n            preEnd: false,\n            requireEndOnly: false\n          };\n          modifiers.setOffsets(arg);\n          modifiers.resetStatuses(arg.statuses);\n          arg.pageCoords = extend({}, interaction.startCoords.page);\n          interaction.modifierResult = modifiers.setAll(arg);\n        },\n        beforeMove: function beforeMove(_ref5) {\n          var interaction = _ref5.interaction,\n            preEnd = _ref5.preEnd,\n            interactingBeforeMove = _ref5.interactingBeforeMove;\n          var modifierResult = modifiers.setAll({\n            interaction: interaction,\n            preEnd: preEnd,\n            pageCoords: interaction.curCoords.page,\n            statuses: interaction.modifierStatuses,\n            requireEndOnly: false\n          });\n\n          // don't fire an action move if a modifier would keep the event in the same\n          // cordinates as before\n          if (!modifierResult.shouldMove && interactingBeforeMove) {\n            interaction._dontFireMove = true;\n          }\n          interaction.modifierResult = modifierResult;\n        },\n        end: function end(_ref6) {\n          var interaction = _ref6.interaction,\n            event = _ref6.event;\n          for (var _i4 = 0; _i4 < modifiers.names.length; _i4++) {\n            var _ref7;\n            _ref7 = modifiers.names[_i4];\n            var modifierName = _ref7;\n            var options = interaction.target.options[interaction.prepared.name][modifierName];\n\n            // if the endOnly option is true for any modifier\n            if (shouldDo(options, true, true)) {\n              // fire a move event at the modified coordinates\n              interaction.doMove({\n                event: event,\n                preEnd: true\n              });\n              break;\n            }\n          }\n        },\n        setXY: function setXY(arg) {\n          var iEvent = arg.iEvent,\n            interaction = arg.interaction;\n          var modifierArg = extend({}, arg);\n          for (var i = 0; i < modifiers.names.length; i++) {\n            var modifierName = modifiers.names[i];\n            modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n            if (!modifierArg.options) {\n              continue;\n            }\n            var modifier = modifiers[modifierName];\n            modifierArg.status = interaction.modifierStatuses[modifierName];\n            iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n          }\n        }\n      };\n      Interaction.signals.on('new', function (interaction) {\n        interaction.startOffset = {\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        };\n        interaction.modifierOffsets = {};\n        interaction.modifierStatuses = modifiers.resetStatuses({});\n        interaction.modifierResult = null;\n      });\n      Interaction.signals.on('action-start', modifiers.start);\n      Interaction.signals.on('action-resume', modifiers.start);\n      Interaction.signals.on('before-action-move', modifiers.beforeMove);\n      Interaction.signals.on('action-end', modifiers.end);\n      InteractEvent.signals.on('set-xy', modifiers.setXY);\n      function shouldDo(options, preEnd, requireEndOnly) {\n        return options && options.enabled && (preEnd || !options.endOnly) && (!requireEndOnly || options.endOnly);\n      }\n      module.exports = modifiers;\n    }, {\n      \"../InteractEvent\": 3,\n      \"../Interaction\": 5,\n      \"../utils/extend\": 41\n    }],\n    24: [function (require, module, exports) {\n      'use strict';\n\n      var modifiers = require('./base');\n      var utils = require('../utils');\n      var defaultOptions = require('../defaultOptions');\n      var restrict = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          restriction: null,\n          elementRect: null\n        },\n        setOffset: function setOffset(_ref) {\n          var rect = _ref.rect,\n            startOffset = _ref.startOffset,\n            options = _ref.options;\n          var elementRect = options && options.elementRect;\n          var offset = {};\n          if (rect && elementRect) {\n            offset.left = startOffset.left - rect.width * elementRect.left;\n            offset.top = startOffset.top - rect.height * elementRect.top;\n            offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n            offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n          } else {\n            offset.left = offset.top = offset.right = offset.bottom = 0;\n          }\n          return offset;\n        },\n        set: function set(_ref2) {\n          var modifiedCoords = _ref2.modifiedCoords,\n            interaction = _ref2.interaction,\n            status = _ref2.status,\n            options = _ref2.options;\n          if (!options) {\n            return status;\n          }\n          var page = status.useStatusXY ? {\n            x: status.x,\n            y: status.y\n          } : utils.extend({}, modifiedCoords);\n          var restriction = getRestrictionRect(options.restriction, interaction, page);\n          if (!restriction) {\n            return status;\n          }\n          status.dx = 0;\n          status.dy = 0;\n          status.locked = false;\n          var rect = restriction;\n          var modifiedX = page.x;\n          var modifiedY = page.y;\n          var offset = interaction.modifierOffsets.restrict;\n\n          // object is assumed to have\n          // x, y, width, height or\n          // left, top, right, bottom\n          if ('x' in restriction && 'y' in restriction) {\n            modifiedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n            modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n          } else {\n            modifiedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n            modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n          }\n          status.dx = modifiedX - page.x;\n          status.dy = modifiedY - page.y;\n          status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n          status.locked = !!(status.dx || status.dy);\n          status.modifiedX = modifiedX;\n          status.modifiedY = modifiedY;\n        },\n        modifyCoords: function modifyCoords(_ref3) {\n          var page = _ref3.page,\n            client = _ref3.client,\n            status = _ref3.status,\n            phase = _ref3.phase,\n            options = _ref3.options;\n          var elementRect = options && options.elementRect;\n          if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n              return {\n                dx: status.dx,\n                dy: status.dy\n              };\n            }\n          }\n        },\n        getRestrictionRect: getRestrictionRect\n      };\n      function getRestrictionRect(value, interaction, page) {\n        if (utils.is.function(value)) {\n          return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\n        } else {\n          return utils.resolveRectLike(value, interaction.target, interaction.element);\n        }\n      }\n      modifiers.restrict = restrict;\n      modifiers.names.push('restrict');\n      defaultOptions.perAction.restrict = restrict.defaults;\n      module.exports = restrict;\n    }, {\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"./base\": 23\n    }],\n    25: [function (require, module, exports) {\n      'use strict';\n\n      // This module adds the options.resize.restrictEdges setting which sets min and\n      // max for the top, left, bottom and right edges of the target being resized.\n      //\n      // interact(target).resize({\n      //   edges: { top: true, left: true },\n      //   restrictEdges: {\n      //     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n      //     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n      //   },\n      // });\n      var modifiers = require('./base');\n      var utils = require('../utils');\n      var rectUtils = require('../utils/rect');\n      var defaultOptions = require('../defaultOptions');\n      var resize = require('../actions/resize');\n      var _require = require('./restrict'),\n        getRestrictionRect = _require.getRestrictionRect;\n      var noInner = {\n        top: +Infinity,\n        left: +Infinity,\n        bottom: -Infinity,\n        right: -Infinity\n      };\n      var noOuter = {\n        top: -Infinity,\n        left: -Infinity,\n        bottom: +Infinity,\n        right: +Infinity\n      };\n      var restrictEdges = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          min: null,\n          max: null,\n          offset: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction,\n            startOffset = _ref.startOffset,\n            options = _ref.options;\n          if (!options) {\n            return utils.extend({}, startOffset);\n          }\n          var offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\n          if (offset) {\n            return {\n              top: startOffset.top + offset.y,\n              left: startOffset.left + offset.x,\n              bottom: startOffset.bottom + offset.y,\n              right: startOffset.right + offset.x\n            };\n          }\n          return startOffset;\n        },\n        set: function set(_ref2) {\n          var modifiedCoords = _ref2.modifiedCoords,\n            interaction = _ref2.interaction,\n            status = _ref2.status,\n            offset = _ref2.offset,\n            options = _ref2.options;\n          var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n          if (!interaction.interacting() || !edges) {\n            return;\n          }\n          var page = status.useStatusXY ? {\n            x: status.x,\n            y: status.y\n          } : utils.extend({}, modifiedCoords);\n          var inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\n          var outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\n          var modifiedX = page.x;\n          var modifiedY = page.y;\n          status.dx = 0;\n          status.dy = 0;\n          status.locked = false;\n          if (edges.top) {\n            modifiedY = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);\n          } else if (edges.bottom) {\n            modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\n          }\n          if (edges.left) {\n            modifiedX = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);\n          } else if (edges.right) {\n            modifiedX = Math.max(Math.min(outer.right - offset.right, page.x), inner.right - offset.right);\n          }\n          status.dx = modifiedX - page.x;\n          status.dy = modifiedY - page.y;\n          status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n          status.locked = !!(status.dx || status.dy);\n          status.modifiedX = modifiedX;\n          status.modifiedY = modifiedY;\n        },\n        modifyCoords: function modifyCoords(_ref3) {\n          var page = _ref3.page,\n            client = _ref3.client,\n            status = _ref3.status,\n            phase = _ref3.phase,\n            options = _ref3.options;\n          if (options && options.enabled && !(phase === 'start' && status.locked)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n              return {\n                dx: status.dx,\n                dy: status.dy\n              };\n            }\n          }\n        },\n        noInner: noInner,\n        noOuter: noOuter,\n        getRestrictionRect: getRestrictionRect\n      };\n      modifiers.restrictEdges = restrictEdges;\n      modifiers.names.push('restrictEdges');\n      defaultOptions.perAction.restrictEdges = restrictEdges.defaults;\n      resize.defaults.restrictEdges = restrictEdges.defaults;\n      module.exports = restrictEdges;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/rect\": 51,\n      \"./base\": 23,\n      \"./restrict\": 24\n    }],\n    26: [function (require, module, exports) {\n      'use strict';\n\n      // This module adds the options.resize.restrictSize setting which sets min and\n      // max width and height for the target being resized.\n      //\n      // interact(target).resize({\n      //   edges: { top: true, left: true },\n      //   restrictSize: {\n      //     min: { width: -600, height: -600 },\n      //     max: { width:  600, height:  600 },\n      //   },\n      // });\n      var modifiers = require('./base');\n      var restrictEdges = require('./restrictEdges');\n      var utils = require('../utils');\n      var rectUtils = require('../utils/rect');\n      var defaultOptions = require('../defaultOptions');\n      var resize = require('../actions/resize');\n      var noMin = {\n        width: -Infinity,\n        height: -Infinity\n      };\n      var noMax = {\n        width: +Infinity,\n        height: +Infinity\n      };\n      var restrictSize = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          min: null,\n          max: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction;\n          return interaction.startOffset;\n        },\n        set: function set(arg) {\n          var interaction = arg.interaction,\n            options = arg.options;\n          var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n          if (!interaction.interacting() || !edges) {\n            return;\n          }\n          var rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n          var minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n          var maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n          arg.options = {\n            enabled: options.enabled,\n            endOnly: options.endOnly,\n            inner: utils.extend({}, restrictEdges.noInner),\n            outer: utils.extend({}, restrictEdges.noOuter)\n          };\n          if (edges.top) {\n            arg.options.inner.top = rect.bottom - minSize.height;\n            arg.options.outer.top = rect.bottom - maxSize.height;\n          } else if (edges.bottom) {\n            arg.options.inner.bottom = rect.top + minSize.height;\n            arg.options.outer.bottom = rect.top + maxSize.height;\n          }\n          if (edges.left) {\n            arg.options.inner.left = rect.right - minSize.width;\n            arg.options.outer.left = rect.right - maxSize.width;\n          } else if (edges.right) {\n            arg.options.inner.right = rect.left + minSize.width;\n            arg.options.outer.right = rect.left + maxSize.width;\n          }\n          restrictEdges.set(arg);\n        },\n        modifyCoords: restrictEdges.modifyCoords\n      };\n      modifiers.restrictSize = restrictSize;\n      modifiers.names.push('restrictSize');\n      defaultOptions.perAction.restrictSize = restrictSize.defaults;\n      resize.defaults.restrictSize = restrictSize.defaults;\n      module.exports = restrictSize;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/rect\": 51,\n      \"./base\": 23,\n      \"./restrictEdges\": 25\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      var modifiers = require('./base');\n      var interact = require('../interact');\n      var utils = require('../utils');\n      var defaultOptions = require('../defaultOptions');\n      var snap = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          range: Infinity,\n          targets: null,\n          offsets: null,\n          relativePoints: null\n        },\n        setOffset: function setOffset(_ref) {\n          var interaction = _ref.interaction,\n            interactable = _ref.interactable,\n            element = _ref.element,\n            rect = _ref.rect,\n            startOffset = _ref.startOffset,\n            options = _ref.options;\n          var offsets = [];\n          var optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\n          var origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n          options = options || interactable.options[interaction.prepared.name].snap || {};\n          var snapOffset = void 0;\n          if (options.offset === 'startCoords') {\n            snapOffset = {\n              x: interaction.startCoords.page.x - origin.x,\n              y: interaction.startCoords.page.y - origin.y\n            };\n          } else {\n            var offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\n            snapOffset = utils.rectToXY(offsetRect) || {\n              x: 0,\n              y: 0\n            };\n          }\n          if (rect && options.relativePoints && options.relativePoints.length) {\n            for (var _i = 0; _i < options.relativePoints.length; _i++) {\n              var _ref3;\n              _ref3 = options.relativePoints[_i];\n              var _ref2 = _ref3;\n              var relativeX = _ref2.x;\n              var relativeY = _ref2.y;\n              offsets.push({\n                x: startOffset.left - rect.width * relativeX + snapOffset.x,\n                y: startOffset.top - rect.height * relativeY + snapOffset.y\n              });\n            }\n          } else {\n            offsets.push(snapOffset);\n          }\n          return offsets;\n        },\n        set: function set(_ref4) {\n          var interaction = _ref4.interaction,\n            modifiedCoords = _ref4.modifiedCoords,\n            status = _ref4.status,\n            options = _ref4.options,\n            offsets = _ref4.offset;\n          var targets = [];\n          var target = void 0;\n          var page = void 0;\n          var i = void 0;\n          if (status.useStatusXY) {\n            page = {\n              x: status.x,\n              y: status.y\n            };\n          } else {\n            var origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n            page = utils.extend({}, modifiedCoords);\n            page.x -= origin.x;\n            page.y -= origin.y;\n          }\n          status.realX = page.x;\n          status.realY = page.y;\n          var len = options.targets ? options.targets.length : 0;\n          for (var _i2 = 0; _i2 < offsets.length; _i2++) {\n            var _ref6;\n            _ref6 = offsets[_i2];\n            var _ref5 = _ref6;\n            var offsetX = _ref5.x;\n            var offsetY = _ref5.y;\n            var relativeX = page.x - offsetX;\n            var relativeY = page.y - offsetY;\n            for (var _i3 = 0; _i3 < (options.targets || []).length; _i3++) {\n              var _ref7;\n              _ref7 = (options.targets || [])[_i3];\n              var snapTarget = _ref7;\n              if (utils.is.function(snapTarget)) {\n                target = snapTarget(relativeX, relativeY, interaction);\n              } else {\n                target = snapTarget;\n              }\n              if (!target) {\n                continue;\n              }\n              targets.push({\n                x: utils.is.number(target.x) ? target.x + offsetX : relativeX,\n                y: utils.is.number(target.y) ? target.y + offsetY : relativeY,\n                range: utils.is.number(target.range) ? target.range : options.range\n              });\n            }\n          }\n          var closest = {\n            target: null,\n            inRange: false,\n            distance: 0,\n            range: 0,\n            dx: 0,\n            dy: 0\n          };\n          for (i = 0, len = targets.length; i < len; i++) {\n            target = targets[i];\n            var range = target.range;\n            var dx = target.x - page.x;\n            var dy = target.y - page.y;\n            var distance = utils.hypot(dx, dy);\n            var inRange = distance <= range;\n\n            // Infinite targets count as being out of range\n            // compared to non infinite ones that are in range\n            if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n              inRange = false;\n            }\n            if (!closest.target || (inRange\n            // is the closest target in range?\n            ? closest.inRange && range !== Infinity\n            // the pointer is relatively deeper in this target\n            ? distance / range < closest.distance / closest.range\n            // this target has Infinite range and the closest doesn't\n            : range === Infinity && closest.range !== Infinity ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance :\n            // The other is not in range and the pointer is closer to this target\n            !closest.inRange && distance < closest.distance)) {\n              closest.target = target;\n              closest.distance = distance;\n              closest.range = range;\n              closest.inRange = inRange;\n              closest.dx = dx;\n              closest.dy = dy;\n              status.range = range;\n            }\n          }\n          var snapChanged = void 0;\n          if (closest.target) {\n            snapChanged = status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y;\n            status.modifiedX = closest.target.x;\n            status.modifiedY = closest.target.y;\n          } else {\n            snapChanged = true;\n            status.modifiedX = NaN;\n            status.modifiedY = NaN;\n          }\n          status.dx = closest.dx;\n          status.dy = closest.dy;\n          status.changed = snapChanged || closest.inRange && !status.locked;\n          status.locked = closest.inRange;\n        },\n        modifyCoords: function modifyCoords(_ref8) {\n          var page = _ref8.page,\n            client = _ref8.client,\n            status = _ref8.status,\n            phase = _ref8.phase,\n            options = _ref8.options;\n          var relativePoints = options && options.relativePoints;\n          if (options && options.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n            if (status.locked) {\n              page.x += status.dx;\n              page.y += status.dy;\n              client.x += status.dx;\n              client.y += status.dy;\n            }\n            return {\n              range: status.range,\n              locked: status.locked,\n              x: status.modifiedX,\n              y: status.modifiedY,\n              realX: status.realX,\n              realY: status.realY,\n              dx: status.dx,\n              dy: status.dy\n            };\n          }\n        }\n      };\n      interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n          var limits = grid.limits || {\n            left: -Infinity,\n            right: Infinity,\n            top: -Infinity,\n            bottom: Infinity\n          };\n          var offsetX = 0;\n          var offsetY = 0;\n          if (utils.is.object(grid.offset)) {\n            offsetX = grid.offset.x;\n            offsetY = grid.offset.y;\n          }\n          var gridx = Math.round((x - offsetX) / grid.x);\n          var gridy = Math.round((y - offsetY) / grid.y);\n          var newX = Math.max(limits.left, Math.min(limits.right, gridx * grid.x + offsetX));\n          var newY = Math.max(limits.top, Math.min(limits.bottom, gridy * grid.y + offsetY));\n          return {\n            x: newX,\n            y: newY,\n            range: grid.range\n          };\n        };\n      };\n      modifiers.snap = snap;\n      modifiers.names.push('snap');\n      defaultOptions.perAction.snap = snap.defaults;\n      module.exports = snap;\n    }, {\n      \"../defaultOptions\": 18,\n      \"../interact\": 21,\n      \"../utils\": 44,\n      \"./base\": 23\n    }],\n    28: [function (require, module, exports) {\n      'use strict';\n\n      // This module allows snapping of the size of targets during resize\n      // interactions.\n      var modifiers = require('./base');\n      var snap = require('./snap');\n      var defaultOptions = require('../defaultOptions');\n      var resize = require('../actions/resize');\n      var utils = require('../utils/');\n      var snapSize = {\n        defaults: {\n          enabled: false,\n          endOnly: false,\n          range: Infinity,\n          targets: null,\n          offsets: null\n        },\n        setOffset: function setOffset(arg) {\n          var interaction = arg.interaction,\n            options = arg.options;\n          var edges = interaction.prepared.edges;\n          if (!edges) {\n            return;\n          }\n          arg.options = {\n            relativePoints: [{\n              x: edges.left ? 0 : 1,\n              y: edges.top ? 0 : 1\n            }],\n            origin: {\n              x: 0,\n              y: 0\n            },\n            offset: 'self',\n            range: options.range\n          };\n          var offsets = snap.setOffset(arg);\n          arg.options = options;\n          return offsets;\n        },\n        set: function set(arg) {\n          var interaction = arg.interaction,\n            options = arg.options,\n            offset = arg.offset,\n            modifiedCoords = arg.modifiedCoords;\n          var page = utils.extend({}, modifiedCoords);\n          var relativeX = page.x - offset[0].x;\n          var relativeY = page.y - offset[0].y;\n          arg.options = utils.extend({}, options);\n          arg.options.targets = [];\n          for (var _i = 0; _i < (options.targets || []).length; _i++) {\n            var _ref;\n            _ref = (options.targets || [])[_i];\n            var snapTarget = _ref;\n            var target = void 0;\n            if (utils.is.function(snapTarget)) {\n              target = snapTarget(relativeX, relativeY, interaction);\n            } else {\n              target = snapTarget;\n            }\n            if (!target) {\n              continue;\n            }\n            if ('width' in target && 'height' in target) {\n              target.x = target.width;\n              target.y = target.height;\n            }\n            arg.options.targets.push(target);\n          }\n          snap.set(arg);\n        },\n        modifyCoords: function modifyCoords(arg) {\n          var options = arg.options;\n          arg.options = utils.extend({}, options);\n          arg.options.enabled = options.enabled;\n          arg.options.relativePoints = [null];\n          snap.modifyCoords(arg);\n        }\n      };\n      modifiers.snapSize = snapSize;\n      modifiers.names.push('snapSize');\n      defaultOptions.perAction.snapSize = snapSize.defaults;\n      resize.defaults.snapSize = snapSize.defaults;\n      module.exports = snapSize;\n    }, {\n      \"../actions/resize\": 10,\n      \"../defaultOptions\": 18,\n      \"../utils/\": 44,\n      \"./base\": 23,\n      \"./snap\": 27\n    }],\n    29: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var pointerUtils = require('../utils/pointerUtils');\n      module.exports = function () {\n        /** */\n        function PointerEvent(type, pointer, event, eventTarget, interaction) {\n          _classCallCheck(this, PointerEvent);\n          pointerUtils.pointerExtend(this, event);\n          if (event !== pointer) {\n            pointerUtils.pointerExtend(this, pointer);\n          }\n          this.interaction = interaction;\n          this.timeStamp = new Date().getTime();\n          this.originalEvent = event;\n          this.type = type;\n          this.pointerId = pointerUtils.getPointerId(pointer);\n          this.pointerType = pointerUtils.getPointerType(pointer);\n          this.target = eventTarget;\n          this.currentTarget = null;\n          if (type === 'tap') {\n            var pointerIndex = interaction.getPointerIndex(pointer);\n            this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\n            var interval = this.timeStamp - interaction.tapTime;\n            this.double = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === this.target && interval < 500);\n          } else if (type === 'doubletap') {\n            this.dt = pointer.timeStamp - interaction.tapTime;\n          }\n        }\n        PointerEvent.prototype.subtractOrigin = function subtractOrigin(_ref) {\n          var originX = _ref.x,\n            originY = _ref.y;\n          this.pageX -= originX;\n          this.pageY -= originY;\n          this.clientX -= originX;\n          this.clientY -= originY;\n          return this;\n        };\n        PointerEvent.prototype.addOrigin = function addOrigin(_ref2) {\n          var originX = _ref2.x,\n            originY = _ref2.y;\n          this.pageX += originX;\n          this.pageY += originY;\n          this.clientX += originX;\n          this.clientY += originY;\n          return this;\n        };\n\n        /** */\n\n        PointerEvent.prototype.preventDefault = function preventDefault() {\n          this.originalEvent.preventDefault();\n        };\n\n        /** */\n\n        PointerEvent.prototype.stopPropagation = function stopPropagation() {\n          this.propagationStopped = true;\n        };\n\n        /** */\n\n        PointerEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n          this.immediatePropagationStopped = this.propagationStopped = true;\n        };\n        return PointerEvent;\n      }();\n    }, {\n      \"../utils/pointerUtils\": 49\n    }],\n    30: [function (require, module, exports) {\n      'use strict';\n\n      var PointerEvent = require('./PointerEvent');\n      var Interaction = require('../Interaction');\n      var utils = require('../utils');\n      var defaults = require('../defaultOptions');\n      var signals = require('../utils/Signals').new();\n      var simpleSignals = ['down', 'up', 'cancel'];\n      var simpleEvents = ['down', 'up', 'cancel'];\n      var pointerEvents = {\n        PointerEvent: PointerEvent,\n        fire: fire,\n        collectEventTargets: collectEventTargets,\n        signals: signals,\n        defaults: {\n          holdDuration: 600,\n          ignoreFrom: null,\n          allowFrom: null,\n          origin: {\n            x: 0,\n            y: 0\n          }\n        },\n        types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']\n      };\n      function fire(arg) {\n        var interaction = arg.interaction,\n          pointer = arg.pointer,\n          event = arg.event,\n          eventTarget = arg.eventTarget,\n          _arg$type = arg.type,\n          type = _arg$type === undefined ? arg.pointerEvent.type : _arg$type,\n          _arg$targets = arg.targets,\n          targets = _arg$targets === undefined ? collectEventTargets(arg) : _arg$targets,\n          _arg$pointerEvent = arg.pointerEvent,\n          pointerEvent = _arg$pointerEvent === undefined ? new PointerEvent(type, pointer, event, eventTarget, interaction) : _arg$pointerEvent;\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          targets: targets,\n          type: type,\n          pointerEvent: pointerEvent\n        };\n        for (var i = 0; i < targets.length; i++) {\n          var target = targets[i];\n          for (var prop in target.props || {}) {\n            pointerEvent[prop] = target.props[prop];\n          }\n          var origin = utils.getOriginXY(target.eventable, target.element);\n          pointerEvent.subtractOrigin(origin);\n          pointerEvent.eventable = target.eventable;\n          pointerEvent.currentTarget = target.element;\n          target.eventable.fire(pointerEvent);\n          pointerEvent.addOrigin(origin);\n          if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].element !== pointerEvent.currentTarget) {\n            break;\n          }\n        }\n        signals.fire('fired', signalArg);\n        if (type === 'tap') {\n          // if pointerEvent should make a double tap, create and fire a doubletap\n          // PointerEvent and use that as the prevTap\n          var prevTap = pointerEvent.double ? fire({\n            interaction: interaction,\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            type: 'doubletap'\n          }) : pointerEvent;\n          interaction.prevTap = prevTap;\n          interaction.tapTime = prevTap.timeStamp;\n        }\n        return pointerEvent;\n      }\n      function collectEventTargets(_ref) {\n        var interaction = _ref.interaction,\n          pointer = _ref.pointer,\n          event = _ref.event,\n          eventTarget = _ref.eventTarget,\n          type = _ref.type;\n        var pointerIndex = interaction.getPointerIndex(pointer);\n\n        // do not fire a tap event if the pointer was moved before being lifted\n        if (type === 'tap' && (interaction.pointerWasMoved\n        // or if the pointerup target is different to the pointerdown target\n        || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n          return [];\n        }\n        var path = utils.getPath(eventTarget);\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          type: type,\n          path: path,\n          targets: [],\n          element: null\n        };\n        for (var _i = 0; _i < path.length; _i++) {\n          var _ref2;\n          _ref2 = path[_i];\n          var element = _ref2;\n          signalArg.element = element;\n          signals.fire('collect-targets', signalArg);\n        }\n        if (type === 'hold') {\n          signalArg.targets = signalArg.targets.filter(function (target) {\n            return target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration;\n          });\n        }\n        return signalArg.targets;\n      }\n      Interaction.signals.on('update-pointer-down', function (_ref3) {\n        var interaction = _ref3.interaction,\n          pointerIndex = _ref3.pointerIndex;\n        interaction.holdTimers[pointerIndex] = {\n          duration: Infinity,\n          timeout: null\n        };\n      });\n      Interaction.signals.on('remove-pointer', function (_ref4) {\n        var interaction = _ref4.interaction,\n          pointerIndex = _ref4.pointerIndex;\n        interaction.holdTimers.splice(pointerIndex, 1);\n      });\n      Interaction.signals.on('move', function (_ref5) {\n        var interaction = _ref5.interaction,\n          pointer = _ref5.pointer,\n          event = _ref5.event,\n          eventTarget = _ref5.eventTarget,\n          duplicateMove = _ref5.duplicateMove;\n        var pointerIndex = interaction.getPointerIndex(pointer);\n        if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n          if (interaction.pointerIsDown) {\n            clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n          }\n          fire({\n            interaction: interaction,\n            pointer: pointer,\n            event: event,\n            eventTarget: eventTarget,\n            type: 'move'\n          });\n        }\n      });\n      Interaction.signals.on('down', function (_ref6) {\n        var interaction = _ref6.interaction,\n          pointer = _ref6.pointer,\n          event = _ref6.event,\n          eventTarget = _ref6.eventTarget,\n          pointerIndex = _ref6.pointerIndex;\n        var timer = interaction.holdTimers[pointerIndex];\n        var path = utils.getPath(eventTarget);\n        var signalArg = {\n          interaction: interaction,\n          pointer: pointer,\n          event: event,\n          eventTarget: eventTarget,\n          type: 'hold',\n          targets: [],\n          path: path,\n          element: null\n        };\n        for (var _i2 = 0; _i2 < path.length; _i2++) {\n          var _ref7;\n          _ref7 = path[_i2];\n          var element = _ref7;\n          signalArg.element = element;\n          signals.fire('collect-targets', signalArg);\n        }\n        if (!signalArg.targets.length) {\n          return;\n        }\n        var minDuration = Infinity;\n        for (var _i3 = 0; _i3 < signalArg.targets.length; _i3++) {\n          var _ref8;\n          _ref8 = signalArg.targets[_i3];\n          var target = _ref8;\n          var holdDuration = target.eventable.options.holdDuration;\n          if (holdDuration < minDuration) {\n            minDuration = holdDuration;\n          }\n        }\n        timer.duration = minDuration;\n        timer.timeout = setTimeout(function () {\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: 'hold'\n          });\n        }, minDuration);\n      });\n      Interaction.signals.on('up', function (_ref9) {\n        var interaction = _ref9.interaction,\n          pointer = _ref9.pointer,\n          event = _ref9.event,\n          eventTarget = _ref9.eventTarget;\n        if (!interaction.pointerWasMoved) {\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: 'tap'\n          });\n        }\n      });\n      var _arr = ['up', 'cancel'];\n      for (var _i4 = 0; _i4 < _arr.length; _i4++) {\n        var signalName = _arr[_i4];\n        Interaction.signals.on(signalName, function (_ref11) {\n          var interaction = _ref11.interaction,\n            pointerIndex = _ref11.pointerIndex;\n          if (interaction.holdTimers[pointerIndex]) {\n            clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n          }\n        });\n      }\n      function createSignalListener(type) {\n        return function (_ref10) {\n          var interaction = _ref10.interaction,\n            pointer = _ref10.pointer,\n            event = _ref10.event,\n            eventTarget = _ref10.eventTarget;\n          fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            pointer: pointer,\n            event: event,\n            type: type\n          });\n        };\n      }\n      for (var i = 0; i < simpleSignals.length; i++) {\n        Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n      }\n      Interaction.signals.on('new', function (interaction) {\n        interaction.prevTap = null; // the most recent tap event on this interaction\n        interaction.tapTime = 0; // time of the most recent tap event\n        interaction.holdTimers = []; // [{ duration, timeout }]\n      });\n\n      defaults.pointerEvents = pointerEvents.defaults;\n      module.exports = pointerEvents;\n    }, {\n      \"../Interaction\": 5,\n      \"../defaultOptions\": 18,\n      \"../utils\": 44,\n      \"../utils/Signals\": 34,\n      \"./PointerEvent\": 29\n    }],\n    31: [function (require, module, exports) {\n      'use strict';\n\n      var pointerEvents = require('./base');\n      var Interaction = require('../Interaction');\n      pointerEvents.signals.on('new', onNew);\n      pointerEvents.signals.on('fired', onFired);\n      var _arr = ['move', 'up', 'cancel', 'endall'];\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var signal = _arr[_i];\n        Interaction.signals.on(signal, endHoldRepeat);\n      }\n      function onNew(_ref) {\n        var pointerEvent = _ref.pointerEvent;\n        if (pointerEvent.type !== 'hold') {\n          return;\n        }\n        pointerEvent.count = (pointerEvent.count || 0) + 1;\n      }\n      function onFired(_ref2) {\n        var interaction = _ref2.interaction,\n          pointerEvent = _ref2.pointerEvent,\n          eventTarget = _ref2.eventTarget,\n          targets = _ref2.targets;\n        if (pointerEvent.type !== 'hold' || !targets.length) {\n          return;\n        }\n\n        // get the repeat interval from the first eventable\n        var interval = targets[0].eventable.options.holdRepeatInterval;\n\n        // don't repeat if the interval is 0 or less\n        if (interval <= 0) {\n          return;\n        }\n\n        // set a timeout to fire the holdrepeat event\n        interaction.holdIntervalHandle = setTimeout(function () {\n          pointerEvents.fire({\n            interaction: interaction,\n            eventTarget: eventTarget,\n            type: 'hold',\n            pointer: pointerEvent,\n            event: pointerEvent\n          });\n        }, interval);\n      }\n      function endHoldRepeat(_ref3) {\n        var interaction = _ref3.interaction;\n\n        // set the interaction's holdStopTime property\n        // to stop further holdRepeat events\n        if (interaction.holdIntervalHandle) {\n          clearInterval(interaction.holdIntervalHandle);\n          interaction.holdIntervalHandle = null;\n        }\n      }\n\n      // don't repeat by default\n      pointerEvents.defaults.holdRepeatInterval = 0;\n      pointerEvents.types.push('holdrepeat');\n      module.exports = {\n        onNew: onNew,\n        onFired: onFired,\n        endHoldRepeat: endHoldRepeat\n      };\n    }, {\n      \"../Interaction\": 5,\n      \"./base\": 30\n    }],\n    32: [function (require, module, exports) {\n      'use strict';\n\n      var pointerEvents = require('./base');\n      var Interactable = require('../Interactable');\n      var is = require('../utils/is');\n      var scope = require('../scope');\n      var extend = require('../utils/extend');\n      var _require = require('../utils/arr'),\n        merge = _require.merge;\n      pointerEvents.signals.on('collect-targets', function (_ref) {\n        var targets = _ref.targets,\n          element = _ref.element,\n          type = _ref.type,\n          eventTarget = _ref.eventTarget;\n        scope.interactables.forEachMatch(element, function (interactable) {\n          var eventable = interactable.events;\n          var options = eventable.options;\n          if (eventable[type] && is.element(element) && interactable.testIgnoreAllow(options, element, eventTarget)) {\n            targets.push({\n              element: element,\n              eventable: eventable,\n              props: {\n                interactable: interactable\n              }\n            });\n          }\n        });\n      });\n      Interactable.signals.on('new', function (_ref2) {\n        var interactable = _ref2.interactable;\n        interactable.events.getRect = function (element) {\n          return interactable.getRect(element);\n        };\n      });\n      Interactable.signals.on('set', function (_ref3) {\n        var interactable = _ref3.interactable,\n          options = _ref3.options;\n        extend(interactable.events.options, pointerEvents.defaults);\n        extend(interactable.events.options, options);\n      });\n      merge(Interactable.eventTypes, pointerEvents.types);\n      Interactable.prototype.pointerEvents = function (options) {\n        extend(this.events.options, options);\n        return this;\n      };\n      var __backCompatOption = Interactable.prototype._backCompatOption;\n      Interactable.prototype._backCompatOption = function (optionName, newValue) {\n        var ret = __backCompatOption.call(this, optionName, newValue);\n        if (ret === this) {\n          this.events.options[optionName] = newValue;\n        }\n        return ret;\n      };\n      Interactable.settingsMethods.push('pointerEvents');\n    }, {\n      \"../Interactable\": 4,\n      \"../scope\": 33,\n      \"../utils/arr\": 35,\n      \"../utils/extend\": 41,\n      \"../utils/is\": 46,\n      \"./base\": 30\n    }],\n    33: [function (require, module, exports) {\n      'use strict';\n\n      var utils = require('./utils');\n      var events = require('./utils/events');\n      var signals = require('./utils/Signals').new();\n      var _require = require('./utils/window'),\n        getWindow = _require.getWindow;\n      var scope = {\n        signals: signals,\n        events: events,\n        utils: utils,\n        // main document\n        document: require('./utils/domObjects').document,\n        // all documents being listened to\n        documents: [],\n        addDocument: function addDocument(doc, win) {\n          // do nothing if document is already known\n          if (utils.contains(scope.documents, doc)) {\n            return false;\n          }\n          win = win || getWindow(doc);\n          scope.documents.push(doc);\n          events.documents.push(doc);\n\n          // don't add an unload event for the main document\n          // so that the page may be cached in browser history\n          if (doc !== scope.document) {\n            events.add(win, 'unload', scope.onWindowUnload);\n          }\n          signals.fire('add-document', {\n            doc: doc,\n            win: win\n          });\n        },\n        removeDocument: function removeDocument(doc, win) {\n          var index = scope.documents.indexOf(doc);\n          win = win || getWindow(doc);\n          events.remove(win, 'unload', scope.onWindowUnload);\n          scope.documents.splice(index, 1);\n          events.documents.splice(index, 1);\n          signals.fire('remove-document', {\n            win: win,\n            doc: doc\n          });\n        },\n        onWindowUnload: function onWindowUnload() {\n          scope.removeDocument(this.document, this);\n        }\n      };\n      module.exports = scope;\n    }, {\n      \"./utils\": 44,\n      \"./utils/Signals\": 34,\n      \"./utils/domObjects\": 38,\n      \"./utils/events\": 40,\n      \"./utils/window\": 52\n    }],\n    34: [function (require, module, exports) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var Signals = function () {\n        function Signals() {\n          _classCallCheck(this, Signals);\n          this.listeners = {\n            // signalName: [listeners],\n          };\n        }\n        Signals.prototype.on = function on(name, listener) {\n          if (!this.listeners[name]) {\n            this.listeners[name] = [listener];\n            return;\n          }\n          this.listeners[name].push(listener);\n        };\n        Signals.prototype.off = function off(name, listener) {\n          if (!this.listeners[name]) {\n            return;\n          }\n          var index = this.listeners[name].indexOf(listener);\n          if (index !== -1) {\n            this.listeners[name].splice(index, 1);\n          }\n        };\n        Signals.prototype.fire = function fire(name, arg) {\n          var targetListeners = this.listeners[name];\n          if (!targetListeners) {\n            return;\n          }\n          for (var _i = 0; _i < targetListeners.length; _i++) {\n            var _ref;\n            _ref = targetListeners[_i];\n            var listener = _ref;\n            if (listener(arg, name) === false) {\n              return;\n            }\n          }\n        };\n        return Signals;\n      }();\n      Signals.new = function () {\n        return new Signals();\n      };\n      module.exports = Signals;\n    }, {}],\n    35: [function (require, module, exports) {\n      \"use strict\";\n\n      function contains(array, target) {\n        return array.indexOf(target) !== -1;\n      }\n      function merge(target, source) {\n        for (var _i = 0; _i < source.length; _i++) {\n          var _ref;\n          _ref = source[_i];\n          var item = _ref;\n          target.push(item);\n        }\n        return target;\n      }\n      module.exports = {\n        contains: contains,\n        merge: merge\n      };\n    }, {}],\n    36: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./window'),\n        window = _require.window;\n      var is = require('./is');\n      var domObjects = require('./domObjects');\n      var Element = domObjects.Element;\n      var navigator = window.navigator;\n      var browser = {\n        // Does the browser support touch input?\n        supportsTouch: !!('ontouchstart' in window || is.function(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch),\n        // Does the browser support PointerEvents\n        supportsPointerEvent: !!domObjects.PointerEvent,\n        isIOS: /iP(hone|od|ad)/.test(navigator.platform),\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n        isIe9: /MSIE 9/.test(navigator.userAgent),\n        // prefix matchesSelector\n        prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n        pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === window.MSPointerEvent ? {\n          up: 'MSPointerUp',\n          down: 'MSPointerDown',\n          over: 'mouseover',\n          out: 'mouseout',\n          move: 'MSPointerMove',\n          cancel: 'MSPointerCancel'\n        } : {\n          up: 'pointerup',\n          down: 'pointerdown',\n          over: 'pointerover',\n          out: 'pointerout',\n          move: 'pointermove',\n          cancel: 'pointercancel'\n        } : null,\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent: 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n      };\n\n      // Opera Mobile must be handled differently\n      browser.isOperaMobile = navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto');\n      module.exports = browser;\n    }, {\n      \"./domObjects\": 38,\n      \"./is\": 46,\n      \"./window\": 52\n    }],\n    37: [function (require, module, exports) {\n      'use strict';\n\n      var is = require('./is');\n      module.exports = function clone(source) {\n        var dest = {};\n        for (var prop in source) {\n          if (is.plainObject(source[prop])) {\n            dest[prop] = clone(source[prop]);\n          } else {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n      };\n    }, {\n      \"./is\": 46\n    }],\n    38: [function (require, module, exports) {\n      'use strict';\n\n      var domObjects = {};\n      var win = require('./window').window;\n      function blank() {}\n      domObjects.document = win.document;\n      domObjects.DocumentFragment = win.DocumentFragment || blank;\n      domObjects.SVGElement = win.SVGElement || blank;\n      domObjects.SVGSVGElement = win.SVGSVGElement || blank;\n      domObjects.SVGElementInstance = win.SVGElementInstance || blank;\n      domObjects.Element = win.Element || blank;\n      domObjects.HTMLElement = win.HTMLElement || domObjects.Element;\n      domObjects.Event = win.Event;\n      domObjects.Touch = win.Touch || blank;\n      domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n      module.exports = domObjects;\n    }, {\n      \"./window\": 52\n    }],\n    39: [function (require, module, exports) {\n      'use strict';\n\n      var win = require('./window');\n      var browser = require('./browser');\n      var is = require('./is');\n      var domObjects = require('./domObjects');\n      var domUtils = {\n        nodeContains: function nodeContains(parent, child) {\n          while (child) {\n            if (child === parent) {\n              return true;\n            }\n            child = child.parentNode;\n          }\n          return false;\n        },\n        closest: function closest(element, selector) {\n          while (is.element(element)) {\n            if (domUtils.matchesSelector(element, selector)) {\n              return element;\n            }\n            element = domUtils.parentNode(element);\n          }\n          return null;\n        },\n        parentNode: function parentNode(node) {\n          var parent = node.parentNode;\n          if (is.docFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && is.docFrag(parent)) {\n              continue;\n            }\n            return parent;\n          }\n          return parent;\n        },\n        matchesSelector: function matchesSelector(element, selector) {\n          // remove /deep/ from selectors if shadowDOM polyfill is used\n          if (win.window !== win.realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n          }\n          return element[browser.prefixedMatchesSelector](selector);\n        },\n        // Test for the element that's \"above\" all other qualifiers\n        indexOfDeepestElement: function indexOfDeepestElement(elements) {\n          var deepestZoneParents = [];\n          var dropzoneParents = [];\n          var dropzone = void 0;\n          var deepestZone = elements[0];\n          var index = deepestZone ? 0 : -1;\n          var parent = void 0;\n          var child = void 0;\n          var i = void 0;\n          var n = void 0;\n          for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n              continue;\n            }\n            if (!deepestZone) {\n              deepestZone = dropzone;\n              index = i;\n              continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n              continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n              deepestZone = dropzone;\n              index = i;\n              continue;\n            }\n            if (!deepestZoneParents.length) {\n              parent = deepestZone;\n              while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                deepestZoneParents.unshift(parent);\n                parent = parent.parentNode;\n              }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n              if (dropzone === deepestZone.parentNode) {\n                continue;\n              }\n              parent = dropzone.ownerSVGElement;\n            } else {\n              parent = dropzone;\n            }\n            dropzoneParents = [];\n            while (parent.parentNode !== parent.ownerDocument) {\n              dropzoneParents.unshift(parent);\n              parent = parent.parentNode;\n            }\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n              n++;\n            }\n            var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n            child = parents[0].lastChild;\n            while (child) {\n              if (child === parents[1]) {\n                deepestZone = dropzone;\n                index = i;\n                deepestZoneParents = [];\n                break;\n              } else if (child === parents[2]) {\n                break;\n              }\n              child = child.previousSibling;\n            }\n          }\n          return index;\n        },\n        matchesUpTo: function matchesUpTo(element, selector, limit) {\n          while (is.element(element)) {\n            if (domUtils.matchesSelector(element, selector)) {\n              return true;\n            }\n            element = domUtils.parentNode(element);\n            if (element === limit) {\n              return domUtils.matchesSelector(element, selector);\n            }\n          }\n          return false;\n        },\n        getActualElement: function getActualElement(element) {\n          return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n        },\n        getScrollXY: function getScrollXY(relevantWindow) {\n          relevantWindow = relevantWindow || win.window;\n          return {\n            x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n            y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n          };\n        },\n        getElementClientRect: function getElementClientRect(element) {\n          var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n          return clientRect && {\n            left: clientRect.left,\n            right: clientRect.right,\n            top: clientRect.top,\n            bottom: clientRect.bottom,\n            width: clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n          };\n        },\n        getElementRect: function getElementRect(element) {\n          var clientRect = domUtils.getElementClientRect(element);\n          if (!browser.isIOS7 && clientRect) {\n            var scroll = domUtils.getScrollXY(win.getWindow(element));\n            clientRect.left += scroll.x;\n            clientRect.right += scroll.x;\n            clientRect.top += scroll.y;\n            clientRect.bottom += scroll.y;\n          }\n          return clientRect;\n        },\n        getPath: function getPath(element) {\n          var path = [];\n          while (element) {\n            path.push(element);\n            element = domUtils.parentNode(element);\n          }\n          return path;\n        },\n        trySelector: function trySelector(value) {\n          if (!is.string(value)) {\n            return false;\n          }\n\n          // an exception will be raised if it is invalid\n          domObjects.document.querySelector(value);\n          return true;\n        }\n      };\n      module.exports = domUtils;\n    }, {\n      \"./browser\": 36,\n      \"./domObjects\": 38,\n      \"./is\": 46,\n      \"./window\": 52\n    }],\n    40: [function (require, module, exports) {\n      'use strict';\n\n      var is = require('./is');\n      var domUtils = require('./domUtils');\n      var pointerUtils = require('./pointerUtils');\n      var pExtend = require('./pointerExtend');\n      var _require = require('./window'),\n        window = _require.window;\n      var _require2 = require('./arr'),\n        contains = _require2.contains;\n      var elements = [];\n      var targets = [];\n\n      // {\n      //   type: {\n      //     selectors: ['selector', ...],\n      //     contexts : [document, ...],\n      //     listeners: [[listener, capture, passive], ...]\n      //   }\n      //  }\n      var delegatedEvents = {};\n      var documents = [];\n      var supportsOptions = function () {\n        var supported = false;\n        window.document.createElement('div').addEventListener('test', null, {\n          get capture() {\n            supported = true;\n          }\n        });\n        return supported;\n      }();\n      function add(element, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var elementIndex = elements.indexOf(element);\n        var target = targets[elementIndex];\n        if (!target) {\n          target = {\n            events: {},\n            typeCount: 0\n          };\n          elementIndex = elements.push(element) - 1;\n          targets.push(target);\n        }\n        if (!target.events[type]) {\n          target.events[type] = [];\n          target.typeCount++;\n        }\n        if (!contains(target.events[type], listener)) {\n          element.addEventListener(type, listener, supportsOptions ? options : !!options.capture);\n          target.events[type].push(listener);\n        }\n      }\n      function remove(element, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var elementIndex = elements.indexOf(element);\n        var target = targets[elementIndex];\n        if (!target || !target.events) {\n          return;\n        }\n        if (type === 'all') {\n          for (type in target.events) {\n            if (target.events.hasOwnProperty(type)) {\n              remove(element, type, 'all');\n            }\n          }\n          return;\n        }\n        if (target.events[type]) {\n          var len = target.events[type].length;\n          if (listener === 'all') {\n            for (var i = 0; i < len; i++) {\n              remove(element, type, target.events[type][i], options);\n            }\n            return;\n          } else {\n            for (var _i = 0; _i < len; _i++) {\n              if (target.events[type][_i] === listener) {\n                element.removeEventListener('on' + type, listener, supportsOptions ? options : !!options.capture);\n                target.events[type].splice(_i, 1);\n                break;\n              }\n            }\n          }\n          if (target.events[type] && target.events[type].length === 0) {\n            target.events[type] = null;\n            target.typeCount--;\n          }\n        }\n        if (!target.typeCount) {\n          targets.splice(elementIndex, 1);\n          elements.splice(elementIndex, 1);\n        }\n      }\n      function addDelegate(selector, context, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        if (!delegatedEvents[type]) {\n          delegatedEvents[type] = {\n            selectors: [],\n            contexts: [],\n            listeners: []\n          };\n\n          // add delegate listener functions\n          for (var _i2 = 0; _i2 < documents.length; _i2++) {\n            var doc = documents[_i2];\n            add(doc, type, delegateListener);\n            add(doc, type, delegateUseCapture, true);\n          }\n        }\n        var delegated = delegatedEvents[type];\n        var index = void 0;\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n            break;\n          }\n        }\n        if (index === -1) {\n          index = delegated.selectors.length;\n          delegated.selectors.push(selector);\n          delegated.contexts.push(context);\n          delegated.listeners.push([]);\n        }\n\n        // keep listener and capture and passive flags\n        delegated.listeners[index].push([listener, !!options.capture, options.passive]);\n      }\n      function removeDelegate(selector, context, type, listener, optionalArg) {\n        var options = getOptions(optionalArg);\n        var delegated = delegatedEvents[type];\n        var matchFound = false;\n        var index = void 0;\n        if (!delegated) {\n          return;\n        }\n\n        // count from last index of delegated to 0\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          // look for matching selector and context Node\n          if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n            var listeners = delegated.listeners[index];\n\n            // each item of the listeners array is an array: [function, capture, passive]\n            for (var i = listeners.length - 1; i >= 0; i--) {\n              var _listeners$i = listeners[i],\n                fn = _listeners$i[0],\n                capture = _listeners$i[1],\n                passive = _listeners$i[2];\n\n              // check if the listener functions and capture and passive flags match\n\n              if (fn === listener && capture === !!options.capture && passive === options.passive) {\n                // remove the listener from the array of listeners\n                listeners.splice(i, 1);\n\n                // if all listeners for this interactable have been removed\n                // remove the interactable from the delegated arrays\n                if (!listeners.length) {\n                  delegated.selectors.splice(index, 1);\n                  delegated.contexts.splice(index, 1);\n                  delegated.listeners.splice(index, 1);\n\n                  // remove delegate function from context\n                  remove(context, type, delegateListener);\n                  remove(context, type, delegateUseCapture, true);\n\n                  // remove the arrays if they are empty\n                  if (!delegated.selectors.length) {\n                    delegatedEvents[type] = null;\n                  }\n                }\n\n                // only remove one listener\n                matchFound = true;\n                break;\n              }\n            }\n            if (matchFound) {\n              break;\n            }\n          }\n        }\n      }\n\n      // bound to the interactable context when a DOM event\n      // listener is added to a selector interactable\n      function delegateListener(event, optionalArg) {\n        var options = getOptions(optionalArg);\n        var fakeEvent = {};\n        var delegated = delegatedEvents[event.type];\n        var _pointerUtils$getEven = pointerUtils.getEventTargets(event),\n          eventTarget = _pointerUtils$getEven[0];\n        var element = eventTarget;\n\n        // duplicate the event so that currentTarget can be changed\n        pExtend(fakeEvent, event);\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (is.element(element)) {\n          for (var i = 0; i < delegated.selectors.length; i++) {\n            var selector = delegated.selectors[i];\n            var context = delegated.contexts[i];\n            if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n              var listeners = delegated.listeners[i];\n              fakeEvent.currentTarget = element;\n              for (var j = 0; j < listeners.length; j++) {\n                var _listeners$j = listeners[j],\n                  fn = _listeners$j[0],\n                  capture = _listeners$j[1],\n                  passive = _listeners$j[2];\n                if (capture === !!options.capture && passive === options.passive) {\n                  fn(fakeEvent);\n                }\n              }\n            }\n          }\n          element = domUtils.parentNode(element);\n        }\n      }\n      function delegateUseCapture(event) {\n        return delegateListener.call(this, event, true);\n      }\n      function preventOriginalDefault() {\n        this.originalEvent.preventDefault();\n      }\n      function getOptions(param) {\n        return is.object(param) ? param : {\n          capture: param\n        };\n      }\n      module.exports = {\n        add: add,\n        remove: remove,\n        addDelegate: addDelegate,\n        removeDelegate: removeDelegate,\n        delegateListener: delegateListener,\n        delegateUseCapture: delegateUseCapture,\n        delegatedEvents: delegatedEvents,\n        documents: documents,\n        supportsOptions: supportsOptions,\n        _elements: elements,\n        _targets: targets\n      };\n    }, {\n      \"./arr\": 35,\n      \"./domUtils\": 39,\n      \"./is\": 46,\n      \"./pointerExtend\": 48,\n      \"./pointerUtils\": 49,\n      \"./window\": 52\n    }],\n    41: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function extend(dest, source) {\n        for (var prop in source) {\n          dest[prop] = source[prop];\n        }\n        return dest;\n      };\n    }, {}],\n    42: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./rect'),\n        resolveRectLike = _require.resolveRectLike,\n        rectToXY = _require.rectToXY;\n      module.exports = function (target, element, action) {\n        var actionOptions = target.options[action];\n        var actionOrigin = actionOptions && actionOptions.origin;\n        var origin = actionOrigin || target.options.origin;\n        var originRect = resolveRectLike(origin, target, element, [target && element]);\n        return rectToXY(originRect) || {\n          x: 0,\n          y: 0\n        };\n      };\n    }, {\n      \"./rect\": 51\n    }],\n    43: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (x, y) {\n        return Math.sqrt(x * x + y * y);\n      };\n    }, {}],\n    44: [function (require, module, exports) {\n      'use strict';\n\n      var extend = require('./extend');\n      var win = require('./window');\n      var utils = {\n        warnOnce: function warnOnce(method, message) {\n          var warned = false;\n          return function () {\n            if (!warned) {\n              win.window.console.warn(message);\n              warned = true;\n            }\n            return method.apply(this, arguments);\n          };\n        },\n        // http://stackoverflow.com/a/5634528/2280888\n        _getQBezierValue: function _getQBezierValue(t, p1, p2, p3) {\n          var iT = 1 - t;\n          return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n        },\n        getQuadraticCurvePoint: function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n          return {\n            x: utils._getQBezierValue(position, startX, cpX, endX),\n            y: utils._getQBezierValue(position, startY, cpY, endY)\n          };\n        },\n        // http://gizma.com/easing/\n        easeOutQuad: function easeOutQuad(t, b, c, d) {\n          t /= d;\n          return -c * t * (t - 2) + b;\n        },\n        copyAction: function copyAction(dest, src) {\n          dest.name = src.name;\n          dest.axis = src.axis;\n          dest.edges = src.edges;\n          return dest;\n        },\n        is: require('./is'),\n        extend: extend,\n        hypot: require('./hypot'),\n        getOriginXY: require('./getOriginXY')\n      };\n      extend(utils, require('./arr'));\n      extend(utils, require('./domUtils'));\n      extend(utils, require('./pointerUtils'));\n      extend(utils, require('./rect'));\n      module.exports = utils;\n    }, {\n      \"./arr\": 35,\n      \"./domUtils\": 39,\n      \"./extend\": 41,\n      \"./getOriginXY\": 42,\n      \"./hypot\": 43,\n      \"./is\": 46,\n      \"./pointerUtils\": 49,\n      \"./rect\": 51,\n      \"./window\": 52\n    }],\n    45: [function (require, module, exports) {\n      'use strict';\n\n      var scope = require('../scope');\n      var utils = require('./index');\n      var finder = {\n        methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'],\n        search: function search(pointer, eventType, eventTarget) {\n          var pointerType = utils.getPointerType(pointer);\n          var pointerId = utils.getPointerId(pointer);\n          var details = {\n            pointer: pointer,\n            pointerId: pointerId,\n            pointerType: pointerType,\n            eventType: eventType,\n            eventTarget: eventTarget\n          };\n          for (var _i = 0; _i < finder.methodOrder.length; _i++) {\n            var _ref;\n            _ref = finder.methodOrder[_i];\n            var method = _ref;\n            var interaction = finder[method](details);\n            if (interaction) {\n              return interaction;\n            }\n          }\n        },\n        // try to resume simulation with a new pointer\n        simulationResume: function simulationResume(_ref2) {\n          var pointerType = _ref2.pointerType,\n            eventType = _ref2.eventType,\n            eventTarget = _ref2.eventTarget;\n          if (!/down|start/i.test(eventType)) {\n            return null;\n          }\n          for (var _i2 = 0; _i2 < scope.interactions.length; _i2++) {\n            var _ref3;\n            _ref3 = scope.interactions[_i2];\n            var interaction = _ref3;\n            var element = eventTarget;\n            if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {\n              while (element) {\n                // if the element is the interaction element\n                if (element === interaction.element) {\n                  return interaction;\n                }\n                element = utils.parentNode(element);\n              }\n            }\n          }\n          return null;\n        },\n        // if it's a mouse or pen interaction\n        mouseOrPen: function mouseOrPen(_ref4) {\n          var pointerId = _ref4.pointerId,\n            pointerType = _ref4.pointerType,\n            eventType = _ref4.eventType;\n          if (pointerType !== 'mouse' && pointerType !== 'pen') {\n            return null;\n          }\n          var firstNonActive = void 0;\n          for (var _i3 = 0; _i3 < scope.interactions.length; _i3++) {\n            var _ref5;\n            _ref5 = scope.interactions[_i3];\n            var interaction = _ref5;\n            if (interaction.pointerType === pointerType) {\n              // if it's a down event, skip interactions with running simulations\n              if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) {\n                continue;\n              }\n\n              // if the interaction is active, return it immediately\n              if (interaction.interacting()) {\n                return interaction;\n              }\n              // otherwise save it and look for another active interaction\n              else if (!firstNonActive) {\n                firstNonActive = interaction;\n              }\n            }\n          }\n\n          // if no active mouse interaction was found use the first inactive mouse\n          // interaction\n          if (firstNonActive) {\n            return firstNonActive;\n          }\n\n          // find any mouse or pen interaction.\n          // ignore the interaction if the eventType is a *down, and a simulation\n          // is active\n          for (var _i4 = 0; _i4 < scope.interactions.length; _i4++) {\n            var _ref6;\n            _ref6 = scope.interactions[_i4];\n            var _interaction = _ref6;\n            if (_interaction.pointerType === pointerType && !(/down/i.test(eventType) && _interaction.simulation)) {\n              return _interaction;\n            }\n          }\n          return null;\n        },\n        // get interaction that has this pointer\n        hasPointer: function hasPointer(_ref7) {\n          var pointerId = _ref7.pointerId;\n          for (var _i5 = 0; _i5 < scope.interactions.length; _i5++) {\n            var _ref8;\n            _ref8 = scope.interactions[_i5];\n            var interaction = _ref8;\n            if (utils.contains(interaction.pointerIds, pointerId)) {\n              return interaction;\n            }\n          }\n        },\n        // get first idle interaction with a matching pointerType\n        idle: function idle(_ref9) {\n          var pointerType = _ref9.pointerType;\n          for (var _i6 = 0; _i6 < scope.interactions.length; _i6++) {\n            var _ref10;\n            _ref10 = scope.interactions[_i6];\n            var interaction = _ref10;\n\n            // if there's already a pointer held down\n            if (interaction.pointerIds.length === 1) {\n              var target = interaction.target;\n              // don't add this pointer if there is a target interactable and it\n              // isn't gesturable\n              if (target && !target.options.gesture.enabled) {\n                continue;\n              }\n            }\n            // maximum of 2 pointers per interaction\n            else if (interaction.pointerIds.length >= 2) {\n              continue;\n            }\n            if (!interaction.interacting() && pointerType === interaction.pointerType) {\n              return interaction;\n            }\n          }\n          return null;\n        }\n      };\n      module.exports = finder;\n    }, {\n      \"../scope\": 33,\n      \"./index\": 44\n    }],\n    46: [function (require, module, exports) {\n      'use strict';\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n      var win = require('./window');\n      var isWindow = require('./isWindow');\n      var is = {\n        array: function array() {},\n        window: function window(thing) {\n          return thing === win.window || isWindow(thing);\n        },\n        docFrag: function docFrag(thing) {\n          return is.object(thing) && thing.nodeType === 11;\n        },\n        object: function object(thing) {\n          return !!thing && (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object';\n        },\n        function: function _function(thing) {\n          return typeof thing === 'function';\n        },\n        number: function number(thing) {\n          return typeof thing === 'number';\n        },\n        bool: function bool(thing) {\n          return typeof thing === 'boolean';\n        },\n        string: function string(thing) {\n          return typeof thing === 'string';\n        },\n        element: function element(thing) {\n          if (!thing || (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) !== 'object') {\n            return false;\n          }\n          var _window = win.getWindow(thing) || win.window;\n          return /object|function/.test(_typeof(_window.Element)) ? thing instanceof _window.Element //DOM2\n          : thing.nodeType === 1 && typeof thing.nodeName === 'string';\n        },\n        plainObject: function plainObject(thing) {\n          return is.object(thing) && thing.constructor.name === 'Object';\n        }\n      };\n      is.array = function (thing) {\n        return is.object(thing) && typeof thing.length !== 'undefined' && is.function(thing.splice);\n      };\n      module.exports = is;\n    }, {\n      \"./isWindow\": 47,\n      \"./window\": 52\n    }],\n    47: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (thing) {\n        return !!(thing && thing.Window) && thing instanceof thing.Window;\n      };\n    }, {}],\n    48: [function (require, module, exports) {\n      'use strict';\n\n      function pointerExtend(dest, source) {\n        for (var prop in source) {\n          var prefixedPropREs = module.exports.prefixedPropREs;\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n          if (!deprecated && typeof source[prop] !== 'function') {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n      }\n      pointerExtend.prefixedPropREs = {\n        webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n      };\n      module.exports = pointerExtend;\n    }, {}],\n    49: [function (require, module, exports) {\n      'use strict';\n\n      var hypot = require('./hypot');\n      var browser = require('./browser');\n      var dom = require('./domObjects');\n      var domUtils = require('./domUtils');\n      var domObjects = require('./domObjects');\n      var is = require('./is');\n      var pointerExtend = require('./pointerExtend');\n      var pointerUtils = {\n        copyCoords: function copyCoords(dest, src) {\n          dest.page = dest.page || {};\n          dest.page.x = src.page.x;\n          dest.page.y = src.page.y;\n          dest.client = dest.client || {};\n          dest.client.x = src.client.x;\n          dest.client.y = src.client.y;\n          dest.timeStamp = src.timeStamp;\n        },\n        setCoordDeltas: function setCoordDeltas(targetObj, prev, cur) {\n          targetObj.page.x = cur.page.x - prev.page.x;\n          targetObj.page.y = cur.page.y - prev.page.y;\n          targetObj.client.x = cur.client.x - prev.client.x;\n          targetObj.client.y = cur.client.y - prev.client.y;\n          targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n          // set pointer velocity\n          var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n          targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n          targetObj.page.vx = targetObj.page.x / dt;\n          targetObj.page.vy = targetObj.page.y / dt;\n          targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n          targetObj.client.vx = targetObj.client.x / dt;\n          targetObj.client.vy = targetObj.client.y / dt;\n        },\n        isNativePointer: function isNativePointer(pointer) {\n          return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n        },\n        // Get specified X/Y coords for mouse or event.touches[0]\n        getXY: function getXY(type, pointer, xy) {\n          xy = xy || {};\n          type = type || 'page';\n          xy.x = pointer[type + 'X'];\n          xy.y = pointer[type + 'Y'];\n          return xy;\n        },\n        getPageXY: function getPageXY(pointer, page) {\n          page = page || {};\n\n          // Opera Mobile handles the viewport and scrolling oddly\n          if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n            pointerUtils.getXY('screen', pointer, page);\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n          } else {\n            pointerUtils.getXY('page', pointer, page);\n          }\n          return page;\n        },\n        getClientXY: function getClientXY(pointer, client) {\n          client = client || {};\n          if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            pointerUtils.getXY('screen', pointer, client);\n          } else {\n            pointerUtils.getXY('client', pointer, client);\n          }\n          return client;\n        },\n        getPointerId: function getPointerId(pointer) {\n          return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n        },\n        setCoords: function setCoords(targetObj, pointers, timeStamp) {\n          var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];\n          var tmpXY = {};\n          pointerUtils.getPageXY(pointer, tmpXY);\n          targetObj.page.x = tmpXY.x;\n          targetObj.page.y = tmpXY.y;\n          pointerUtils.getClientXY(pointer, tmpXY);\n          targetObj.client.x = tmpXY.x;\n          targetObj.client.y = tmpXY.y;\n          targetObj.timeStamp = is.number(timeStamp) ? timeStamp : new Date().getTime();\n        },\n        pointerExtend: pointerExtend,\n        getTouchPair: function getTouchPair(event) {\n          var touches = [];\n\n          // array of touches is supplied\n          if (is.array(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n          }\n          // an event\n          else {\n            if (event.type === 'touchend') {\n              if (event.touches.length === 1) {\n                touches[0] = event.touches[0];\n                touches[1] = event.changedTouches[0];\n              } else if (event.touches.length === 0) {\n                touches[0] = event.changedTouches[0];\n                touches[1] = event.changedTouches[1];\n              }\n            } else {\n              touches[0] = event.touches[0];\n              touches[1] = event.touches[1];\n            }\n          }\n          return touches;\n        },\n        pointerAverage: function pointerAverage(pointers) {\n          var average = {\n            pageX: 0,\n            pageY: 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n          };\n          for (var _i = 0; _i < pointers.length; _i++) {\n            var _ref;\n            _ref = pointers[_i];\n            var pointer = _ref;\n            for (var _prop in average) {\n              average[_prop] += pointer[_prop];\n            }\n          }\n          for (var prop in average) {\n            average[prop] /= pointers.length;\n          }\n          return average;\n        },\n        touchBBox: function touchBBox(event) {\n          if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n          }\n          var touches = pointerUtils.getTouchPair(event);\n          var minX = Math.min(touches[0].pageX, touches[1].pageX);\n          var minY = Math.min(touches[0].pageY, touches[1].pageY);\n          var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n          var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n          return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n          };\n        },\n        touchDistance: function touchDistance(event, deltaSource) {\n          var sourceX = deltaSource + 'X';\n          var sourceY = deltaSource + 'Y';\n          var touches = pointerUtils.getTouchPair(event);\n          var dx = touches[0][sourceX] - touches[1][sourceX];\n          var dy = touches[0][sourceY] - touches[1][sourceY];\n          return hypot(dx, dy);\n        },\n        touchAngle: function touchAngle(event, prevAngle, deltaSource) {\n          var sourceX = deltaSource + 'X';\n          var sourceY = deltaSource + 'Y';\n          var touches = pointerUtils.getTouchPair(event);\n          var dx = touches[1][sourceX] - touches[0][sourceX];\n          var dy = touches[1][sourceY] - touches[0][sourceY];\n          var angle = 180 * Math.atan2(dy, dx) / Math.PI;\n          return angle;\n        },\n        getPointerType: function getPointerType(pointer) {\n          return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]\n          // if the PointerEvent API isn't available, then the \"pointer\" must\n          // be either a MouseEvent, TouchEvent, or Touch object\n          : /touch/.test(pointer.type) || pointer instanceof domObjects.Touch ? 'touch' : 'mouse';\n        },\n        // [ event.target, event.currentTarget ]\n        getEventTargets: function getEventTargets(event) {\n          var path = is.function(event.composedPath) ? event.composedPath() : event.path;\n          return [domUtils.getActualElement(path ? path[0] : event.target), domUtils.getActualElement(event.currentTarget)];\n        }\n      };\n      module.exports = pointerUtils;\n    }, {\n      \"./browser\": 36,\n      \"./domObjects\": 38,\n      \"./domUtils\": 39,\n      \"./hypot\": 43,\n      \"./is\": 46,\n      \"./pointerExtend\": 48\n    }],\n    50: [function (require, module, exports) {\n      'use strict';\n\n      var _require = require('./window'),\n        window = _require.window;\n      var vendors = ['ms', 'moz', 'webkit', 'o'];\n      var lastTime = 0;\n      var request = void 0;\n      var cancel = void 0;\n      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n        request = window[vendors[x] + 'RequestAnimationFrame'];\n        cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n      }\n      if (!request) {\n        request = function request(callback) {\n          var currTime = new Date().getTime();\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          var id = setTimeout(function () {\n            callback(currTime + timeToCall);\n          }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n      if (!cancel) {\n        cancel = function cancel(id) {\n          clearTimeout(id);\n        };\n      }\n      module.exports = {\n        request: request,\n        cancel: cancel\n      };\n    }, {\n      \"./window\": 52\n    }],\n    51: [function (require, module, exports) {\n      'use strict';\n\n      var extend = require('./extend');\n      var is = require('./is');\n      var _require = require('./domUtils'),\n        closest = _require.closest,\n        parentNode = _require.parentNode,\n        getElementRect = _require.getElementRect;\n      var rectUtils = {\n        getStringOptionResult: function getStringOptionResult(value, interactable, element) {\n          if (!is.string(value)) {\n            return null;\n          }\n          if (value === 'parent') {\n            value = parentNode(element);\n          } else if (value === 'self') {\n            value = interactable.getRect(element);\n          } else {\n            value = closest(element, value);\n          }\n          return value;\n        },\n        resolveRectLike: function resolveRectLike(value, interactable, element, functionArgs) {\n          value = rectUtils.getStringOptionResult(value, interactable, element) || value;\n          if (is.function(value)) {\n            value = value.apply(null, functionArgs);\n          }\n          if (is.element(value)) {\n            value = getElementRect(value);\n          }\n          return value;\n        },\n        rectToXY: function rectToXY(rect) {\n          return rect && {\n            x: 'x' in rect ? rect.x : rect.left,\n            y: 'y' in rect ? rect.y : rect.top\n          };\n        },\n        xywhToTlbr: function xywhToTlbr(rect) {\n          if (rect && !('left' in rect && 'top' in rect)) {\n            rect = extend({}, rect);\n            rect.left = rect.x || 0;\n            rect.top = rect.y || 0;\n            rect.right = rect.right || rect.left + rect.width;\n            rect.bottom = rect.bottom || rect.top + rect.height;\n          }\n          return rect;\n        },\n        tlbrToXywh: function tlbrToXywh(rect) {\n          if (rect && !('x' in rect && 'y' in rect)) {\n            rect = extend({}, rect);\n            rect.x = rect.left || 0;\n            rect.top = rect.top || 0;\n            rect.width = rect.width || rect.right - rect.x;\n            rect.height = rect.height || rect.bottom - rect.y;\n          }\n          return rect;\n        }\n      };\n      module.exports = rectUtils;\n    }, {\n      \"./domUtils\": 39,\n      \"./extend\": 41,\n      \"./is\": 46\n    }],\n    52: [function (require, module, exports) {\n      'use strict';\n\n      var win = module.exports;\n      var isWindow = require('./isWindow');\n      function init(window) {\n        // get wrapped window if using Shadow DOM polyfill\n\n        win.realWindow = window;\n\n        // create a TextNode\n        var el = window.document.createTextNode('');\n\n        // check if it's wrapped by a polyfill\n        if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n          // use wrapped window\n          window = window.wrap(window);\n        }\n        win.window = window;\n      }\n      if (typeof window === 'undefined') {\n        win.window = undefined;\n        win.realWindow = undefined;\n      } else {\n        init(window);\n      }\n      win.getWindow = function getWindow(node) {\n        if (isWindow(node)) {\n          return node;\n        }\n        var rootNode = node.ownerDocument || node;\n        return rootNode.defaultView || rootNode.parentWindow || win.window;\n      };\n      win.init = init;\n    }, {\n      \"./isWindow\": 47\n    }]\n  }, {}, [1])(1);\n});","map":{"version":3,"names":["f","exports","module","define","amd","g","window","global","self","interact","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","init","extend","fireUntilImmediateStopped","event","listeners","_i","_ref","listener","immediatePropagationStopped","Eventable","options","_classCallCheck","fire","onEvent","type","propagationStopped","on","eventType","push","off","eventList","index","indexOf","splice","undefined","getOriginXY","defaults","signals","new","InteractEvent","interaction","action","phase","element","related","preEnd","arguments","target","deltaSource","origin","starting","ending","coords","startCoords","curCoords","prevEvent","page","client","x","y","ctrlKey","altKey","shiftKey","metaKey","button","buttons","currentTarget","relatedTarget","interactable","t0","downTimes","signalArg","iEvent","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","timeStamp","dt","pointerDelta","duration","speed","velocityX","vx","velocityY","vy","swipe","getSwipe","angle","Math","atan2","PI","overlap","left","up","right","down","velocity","preventDefault","stopImmediatePropagation","stopPropagation","dx","dy","clone","is","events","actions","scope","getElementRect","nodeContains","trySelector","matchesSelector","getWindow","contains","wheelEvent","interactables","Interactable","_context","context","document","_win","_doc","win","addDocument","set","setOnEvents","phases","onAction","function","onstart","onmove","onend","oninertiastart","setPerAction","option","object","perAction","enabled","bool","getRect","string","querySelector","rectChecker","checker","_backCompatOption","optionName","newValue","names","inContext","ownerDocument","_onOffMultiple","method","search","trim","split","array","_i2","_ref2","prop","eventTypes","addDelegate","add","removeDelegate","remove","base","perActions","actionName","methodDict","methodName","_i3","settingsMethods","_ref3","setting","unset","delegatedEvents","delegated","selectors","contexts","delegateListener","delegateUseCapture","_i4","interactions","_ref4","interacting","_ending","stop","indexOfElement","get","interactableGet","dontCheckInContext","ret","forEachMatch","callback","_i5","_ref5","utils","browser","domObjects","finder","methodNames","prevTouchTime","Interaction","pointerType","prepared","name","axis","edges","pointers","pointerIds","downTargets","prevCoords","downEvent","downPointer","_eventTarget","_curEventTarget","pointerIsDown","pointerWasMoved","_interacting","pointerDown","pointer","eventTarget","pointerIndex","updatePointer","start","copyAction","pointerMove","simulation","setCoords","duplicateMove","hypot","pointerMoveTolerance","getPointerIndex","duplicate","interactingBeforeMove","setCoordDeltas","doMove","copyCoords","_dontFireMove","pointerUp","curEventTarget","test","end","removePointer","currentAction","getPointerId","id","pointerId","_updateEventTargets","doOnInteractions","getPointerType","_utils$getEventTarget","getEventTargets","matches","supportsTouch","Date","getTime","changedTouches","changedTouch","invalidPointer","supportsPointerEvent","_interaction","_pointer","_interaction2","endAll","docEvents","pEventTypes","PointerEvent","move","cancel","mousedown","mousemove","mouseup","touchstart","touchmove","touchend","touchcancel","blur","onDocSignal","signalName","doc","eventMethod","_eventType","isIOS","passive","_ref6","pointerExtend","endAllInteractions","firePrepared","newEvent","defaultOptions","drag","mouseButtons","snap","restrict","inertia","autoScroll","startAxis","lockAxis","dragOptions","getCursor","abs","prototype","draggable","ondragstart","ondragend","merge","drop","accept","dynamicDrop","activeDrops","dropzones","elements","rects","dropEvents","setActiveDrops","dragEvent","getDropEvents","activate","fireActiveDrops","draggableElement","dropResult","getDrop","dropTarget","dropzone","dropElement","fireDropEvents","collectDrops","drops","current","dropElements","querySelectorAll","_ref7","currentElement","prevElement","dragElement","possibleDrops","validDrops","j","rect","dropCheck","dropIndex","indexOfDeepestElement","pointerEvent","enter","leave","deactivate","tmpl","prevDropElement","prevDropTarget","dragLeave","prevDropzone","dragEnter","dragmove","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","number","max","min","dropped","dropOverlap","getPageXY","horizontal","vertical","top","bottom","dragRect","cx","width","cy","height","overlapArea","overlapRatio","_ref8","_ref9","gesture","ds","startDistance","prevDistance","distance","startAngle","prevAngle","scale","Infinity","isNaN","gesturable","ongesturestart","ongestureend","touches","touchDistance","box","touchBBox","touchAngle","da","prevScale","defaultMargin","resize","square","preserveAspectRatio","margin","NaN","invert","resizeOptions","resizeEdges","edge","checkResizeEdge","axes","cursors","isIe9","xy","topleft","bottomright","topright","bottomleft","cursorKey","edgeNames","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","inverted","previous","delta","deltaRect","invertible","originalEdges","startAspectRatio","swap","resizable","onresizestart","onresizeend","value","interactableElement","matchesUpTo","resizeAxes","raf","domUtils","container","isScrolling","prevTime","request","scroll","now","scrollBy","scrollLeft","scrollTop","check","onInteractionMove","innerWidth","innerHeight","getElementClientRect","warnOnce","getAction","defaultActionChecker","actionChecker","ignoreFrom","allowFrom","testIgnore","testAllow","testIgnoreAllow","styleCursor","autoStart","withinInteractionLimit","maxInteractions","manualStart","maxPerElement","setActionDefaults","validateAction","actionInfo","getActionInfo","prepare","arg","validateSelector","matchElements","len","match","matchElement","pushMatches","parentNode","documentElement","style","cursor","maxActions","activeInteractions","targetCount","targetElementCount","otherAction","absX","absY","targetOptions","currentAxis","getDraggable","checkStartAxis","thisAxis","hold","delay","autoStartHoldTimer","getHoldDuration","setTimeout","clearTimeout","resistance","minSpeed","endSpeed","allowResume","smoothEndDuration","modifiers","animationFrame","inertiaStatus","active","smoothEnd","startEvent","upCoords","xe","ye","sx","sy","vx0","vys","lambda_v0","one_ve_v0","boundInertiaFrame","inertiaFrame","apply","boundSmoothEndFrame","smoothEndFrame","status","resumeEvent","resetStatuses","modifierStatuses","inertiaOptions","statuses","pointerSpeed","modifierResult","inertiaPossible","modifierArg","pageCoords","requireEndOnly","setAll","shouldMove","locked","vy0","v0","calcInertia","modifiedXe","modifiedYe","lambda","inertiaDur","log","te","updateInertiaCoords","progress","exp","quadPoint","getQuadraticCurvePoint","easeOutQuad","pageUp","clientUp","globalEvents","isSet","debug","getPointerAverage","pointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","closest","removeDocument","checkAndPreventDefault","supportsPassive","onInteractionEvent","_arr","eventSignal","dragstart","preventNativeDrag","setOffsets","startOffset","modifierName","modifierOffsets","setOffset","result","changed","modifiedCoords","modifier","shouldDo","offset","modifiedX","modifiedY","beforeMove","setXY","modifyCoords","endOnly","restriction","elementRect","useStatusXY","getRestrictionRect","resolveRectLike","rectUtils","noInner","noOuter","restrictEdges","inner","xywhToTlbr","outer","noMin","noMax","restrictSize","minSize","tlbrToXywh","maxSize","range","targets","offsets","relativePoints","optionsOrigin","rectToXY","snapOffset","offsetRect","relativeX","relativeY","realX","realY","offsetX","offsetY","snapTarget","inRange","snapChanged","createSnapGrid","grid","limits","gridx","round","gridy","newX","newY","snapSize","pointerUtils","originalEvent","interval","tapTime","double","prevTap","subtractOrigin","originX","originY","addOrigin","simpleSignals","simpleEvents","pointerEvents","collectEventTargets","holdDuration","types","_arg$type","_arg$targets","_arg$pointerEvent","props","eventable","path","getPath","filter","holdTimers","timeout","timer","minDuration","_ref11","createSignalListener","_ref10","onNew","onFired","signal","endHoldRepeat","count","holdRepeatInterval","holdIntervalHandle","clearInterval","__backCompatOption","documents","onWindowUnload","Signals","targetListeners","source","item","Element","navigator","DocumentTouch","platform","isIOS7","appVersion","userAgent","prefixedMatchesSelector","MSPointerEvent","over","out","isOperaMobile","appName","dest","plainObject","blank","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch","parent","child","selector","node","docFrag","host","realWindow","replace","deepestZoneParents","dropzoneParents","deepestZone","unshift","ownerSVGElement","parents","lastChild","previousSibling","limit","getActualElement","correspondingUseElement","getScrollXY","relevantWindow","scrollX","scrollY","clientRect","getBoundingClientRect","getClientRects","pExtend","supportsOptions","supported","createElement","addEventListener","capture","optionalArg","getOptions","elementIndex","typeCount","hasOwnProperty","removeEventListener","matchFound","_listeners$i","fn","fakeEvent","_pointerUtils$getEven","preventOriginalDefault","_listeners$j","param","_elements","_targets","actionOptions","actionOrigin","originRect","sqrt","message","warned","console","warn","_getQBezierValue","p1","p2","p3","iT","startX","startY","cpX","cpY","endX","endY","position","b","c","d","src","methodOrder","details","simulationResume","mouseOrPen","firstNonActive","hasPointer","idle","_i6","isWindow","thing","nodeType","_typeof","_function","_window","nodeName","constructor","Window","prefixedPropREs","deprecated","vendor","webkit","dom","targetObj","prev","cur","isNativePointer","getXY","getClientXY","identifier","tmpXY","getTouchPair","average","screenX","screenY","_prop","minX","minY","maxX","maxY","sourceX","sourceY","composedPath","vendors","lastTime","requestAnimationFrame","currTime","timeToCall","getStringOptionResult","functionArgs","el","createTextNode","wrap","rootNode","defaultView","parentWindow"],"sources":["C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\header.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\node_modules\\browser-pack\\_prelude.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\index.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\Eventable.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\InteractEvent.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\Interactable.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\Interaction.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\actions\\base.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\actions\\drag.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\actions\\drop.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\actions\\gesture.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\actions\\resize.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoScroll.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\InteractableMethods.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\base.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\drag.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\gesture.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\hold.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\autoStart\\resize.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\defaultOptions.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\index.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\inertia.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\interact.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\interactablePreventDefault.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\base.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\restrict.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\restrictEdges.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\restrictSize.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\snap.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\modifiers\\snapSize.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\pointerEvents\\PointerEvent.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\pointerEvents\\base.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\pointerEvents\\holdRepeat.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\pointerEvents\\interactableTargets.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\scope.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\Signals.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\arr.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\browser.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\clone.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\domObjects.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\domUtils.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\events.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\extend.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\getOriginXY.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\hypot.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\index.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\interactionFinder.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\is.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\isWindow.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\pointerExtend.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\pointerUtils.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\raf.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\rect.js","C:\\Users\\Ramith\\Projects\\Application Scanner\\scanner-app\\react-app\\node_modules\\interactjs\\dist\\src\\utils\\window.js"],"sourcesContent":["/**\n * interact.js v1.3.4\n *\n * Copyright (c) 2012-2018 Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n}\nelse {\n  module.exports = require('./src/index');\n}\n","const extend = require('./utils/extend.js');\n\nfunction fireUntilImmediateStopped (event, listeners) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) { break; }\n\n    listener(event);\n  }\n}\n\nclass Eventable {\n\n  constructor (options) {\n    this.options = extend({}, options || {});\n  }\n\n  fire (event) {\n    let listeners;\n    const onEvent = 'on' + event.type;\n    const global = this.global;\n\n    // Interactable#on() listeners\n    if ((listeners = this[event.type])) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n\n    // interactable.onevent listener\n    if (this[onEvent]) {\n      this[onEvent](event);\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\n      fireUntilImmediateStopped(event, listeners);\n    }\n  }\n\n  on (eventType, listener) {\n    // if this type of event was never bound\n    if (this[eventType]) {\n      this[eventType].push(listener);\n    }\n    else {\n      this[eventType] = [listener];\n    }\n  }\n\n  off (eventType, listener) {\n    // if it is an action event type\n    const eventList = this[eventType];\n    const index     = eventList? eventList.indexOf(listener) : -1;\n\n    if (index !== -1) {\n      eventList.splice(index, 1);\n    }\n\n    if (eventList && eventList.length === 0 || !listener) {\n      this[eventType] = undefined;\n    }\n  }\n}\n\nmodule.exports = Eventable;\n","const extend      = require('./utils/extend');\nconst getOriginXY = require('./utils/getOriginXY');\nconst defaults    = require('./defaultOptions');\nconst signals     = require('./utils/Signals').new();\n\nclass InteractEvent {\n  /** */\n  constructor (interaction, event, action, phase, element, related, preEnd = false) {\n    const target      = interaction.target;\n    const deltaSource = (target && target.options || defaults).deltaSource;\n    const origin      = getOriginXY(target, element, action);\n    const starting    = phase === 'start';\n    const ending      = phase === 'end';\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\n    const prevEvent   = interaction.prevEvent;\n\n    element = element || interaction.element;\n\n    const page   = extend({}, coords.page);\n    const client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey       = event.ctrlKey;\n    this.altKey        = event.altKey;\n    this.shiftKey      = event.shiftKey;\n    this.metaKey       = event.metaKey;\n    this.button        = event.button;\n    this.buttons       = event.buttons;\n    this.target        = element;\n    this.currentTarget = element;\n    this.relatedTarget = related || null;\n    this.preEnd        = preEnd;\n    this.type          = action + (phase || '');\n    this.interaction   = interaction;\n    this.interactable  = target;\n\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1]\n                       : prevEvent.t0;\n\n    const signalArg = {\n      interaction,\n      event,\n      action,\n      phase,\n      element,\n      related,\n      page,\n      client,\n      coords,\n      starting,\n      ending,\n      deltaSource,\n      iEvent: this,\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    }\n    else {\n      this.pageX     = page.x;\n      this.pageY     = page.y;\n      this.clientX   = client.x;\n      this.clientY   = client.y;\n    }\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n\n    this.timeStamp = coords.timeStamp;\n    this.dt        = interaction.pointerDelta.timeStamp;\n    this.duration  = this.timeStamp - this.t0;\n\n    // speed and velocity in pixels per second\n    this.speed = interaction.pointerDelta[deltaSource].speed;\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\n    this.swipe = (ending || phase === 'inertiastart')? this.getSwipe() : null;\n\n    signals.fire('new', signalArg);\n  }\n\n  getSwipe () {\n    const interaction = this.interaction;\n\n    if (interaction.prevEvent.speed < 600\n        || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null;\n    }\n\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n    const overlap = 22.5;\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap;\n    const up   = 225 - overlap <= angle && angle < 315 + overlap;\n\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    };\n  }\n\n  preventDefault () {}\n\n  /** */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n\n  /** */\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n}\n\nsignals.on('set-delta', function ({ iEvent, interaction, starting, deltaSource }) {\n  const prevEvent = starting? iEvent : interaction.prevEvent;\n\n  if (deltaSource === 'client') {\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\n  }\n  else {\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n","const clone     = require('./utils/clone');\nconst is        = require('./utils/is');\nconst events    = require('./utils/events');\nconst extend    = require('./utils/extend');\nconst actions   = require('./actions/base');\nconst scope     = require('./scope');\nconst Eventable = require('./Eventable');\nconst defaults  = require('./defaultOptions');\nconst signals   = require('./utils/Signals').new();\n\nconst {\n  getElementRect,\n  nodeContains,\n  trySelector,\n  matchesSelector,\n}                    = require('./utils/domUtils');\nconst { getWindow }  = require('./utils/window');\nconst { contains }   = require('./utils/arr');\nconst { wheelEvent } = require('./utils/browser');\n\n// all set interactables\nscope.interactables = [];\n\nclass Interactable {\n  /** */\n  constructor (target, options) {\n    options = options || {};\n\n    this.target   = target;\n    this.events   = new Eventable();\n    this._context = options.context || scope.document;\n    this._win     = getWindow(trySelector(target)? this._context : target);\n    this._doc     = this._win.document;\n\n    signals.fire('new', {\n      target,\n      options,\n      interactable: this,\n      win: this._win,\n    });\n\n    scope.addDocument( this._doc, this._win );\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  setOnEvents (action, phases) {\n    const onAction = 'on' + action;\n\n    if (is.function(phases.onstart)       ) { this.events[onAction + 'start'        ] = phases.onstart         ; }\n    if (is.function(phases.onmove)        ) { this.events[onAction + 'move'         ] = phases.onmove          ; }\n    if (is.function(phases.onend)         ) { this.events[onAction + 'end'          ] = phases.onend           ; }\n    if (is.function(phases.oninertiastart)) { this.events[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\n\n    return this;\n  }\n\n  setPerAction (action, options) {\n    // for all the default per-action options\n    for (const option in options) {\n      // if this option exists for this action\n      if (option in defaults[action]) {\n        // if the option in the options arg is an object value\n        if (is.object(options[option])) {\n          // duplicate the object and merge\n          this.options[action][option] = clone(this.options[action][option] || {});\n          extend(this.options[action][option], options[option]);\n\n          if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\n          }\n        }\n        else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        }\n        else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {object} The object's bounding rectangle.\n   */\n  getRect (element) {\n    element = element || this.target;\n\n    if (is.string(this.target) && !(is.element(element))) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (checker) {\n    if (is.function(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  }\n\n  _backCompatOption (optionName, newValue) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      this.options[optionName] = newValue;\n\n      for (const action of actions.names) {\n        this.options[action][optionName] = newValue;\n      }\n\n      return this;\n    }\n\n    return this.options[optionName];\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue) {\n    return this._backCompatOption('origin', newValue);\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context;\n  }\n\n  inContext (element) {\n    return (this._context === element.ownerDocument\n            || nodeContains(this._context, element));\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent) {\n    this.events.fire(iEvent);\n\n    return this;\n  }\n\n  _onOffMultiple (method, eventType, listener, options) {\n    if (is.string(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (is.array(eventType)) {\n      for (const type of eventType) {\n        this[method](type, listener, options);\n      }\n\n      return true;\n    }\n\n    if (is.object(eventType)) {\n      for (const prop in eventType) {\n        this[method](prop, eventType[prop], listener);\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} eventType  The types of events to listen\n   * for\n   * @param {function} listener   The function event (s)\n   * @param {object | boolean} [options]    options object or useCapture flag\n   * for addEventListener\n   * @return {object} This Interactable\n   */\n  on (eventType, listener, options) {\n    if (this._onOffMultiple('on', eventType, listener, options)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.on(eventType, listener);\n    }\n    // delegated event for selector\n    else if (is.string(this.target)) {\n      events.addDelegate(this.target, this._context, eventType, listener, options);\n    }\n    else {\n      events.add(this.target, eventType, listener, options);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener\n   *\n   * @param {string | array | object} eventType The types of events that were\n   * listened for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {object} This Interactable\n   */\n  off (eventType, listener, options) {\n    if (this._onOffMultiple('off', eventType, listener, options)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    // if it is an action event type\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.off(eventType, listener);\n    }\n    // delegated event\n    else if (is.string(this.target)) {\n      events.removeDelegate(this.target, this._context, eventType, listener, options);\n    }\n    // remove listener from this Interatable's element\n    else {\n      events.remove(this.target, eventType, listener, options);\n    }\n\n    return this;\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options) {\n    if (!is.object(options)) {\n      options = {};\n    }\n\n    this.options = clone(defaults.base);\n\n    const perActions = clone(defaults.perAction);\n\n    for (const actionName in actions.methodDict) {\n      const methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = clone(defaults[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (const setting of Interactable.settingsMethods) {\n      this.options[setting] = defaults.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    signals.fire('set', {\n      options,\n      interactable: this,\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   *\n   * @return {interact}\n   */\n  unset () {\n    events.remove(this.target, 'all');\n\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type];\n\n        if (delegated.selectors[0] === this.target\n            && delegated.contexts[0] === this._context) {\n\n          delegated.selectors.splice(0, 1);\n          delegated.contexts .splice(0, 1);\n          delegated.listeners.splice(0, 1);\n\n          // remove the arrays if they are empty\n          if (!delegated.selectors.length) {\n            delegated[type] = null;\n          }\n        }\n\n        events.remove(this._context, type, events.delegateListener);\n        events.remove(this._context, type, events.delegateUseCapture, true);\n      }\n    }\n    else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(scope.interactables.indexOf(this), 1);\n\n    // Stop related interactions when an Interactable is unset\n    for (const interaction of scope.interactions || []) {\n      if (interaction.target === this && interaction.interacting() && !interaction._ending) {\n        interaction.stop();\n      }\n    }\n\n    return scope.interact;\n  }\n}\n\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\n  context = context || scope.document;\n\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if (interactable.target === target && interactable._context === context) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet (element, options, dontCheckInContext) {\n  const ret = this[this.indexOfElement(element, options && options.context)];\n\n  return ret && (is.string(element) || dontCheckInContext || ret.inContext(element))? ret : null;\n};\n\nscope.interactables.forEachMatch = function (element, callback) {\n  for (const interactable of this) {\n    let ret;\n\n    if ((is.string(interactable.target)\n        // target is a selector and the element matches\n        ? (is.element(element) && matchesSelector(element, interactable.target))\n        // target is the element\n        : element === interactable.target)\n        // the element is in context\n      && (interactable.inContext(element))) {\n      ret = callback(interactable);\n    }\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n// all interact.js eventTypes\nInteractable.eventTypes = scope.eventTypes = [];\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker' ];\n\nmodule.exports = Interactable;\n","const scope      = require('./scope');\nconst utils      = require('./utils');\nconst events     = require('./utils/events');\nconst browser    = require('./utils/browser');\nconst domObjects = require('./utils/domObjects');\nconst finder     = require('./utils/interactionFinder');\nconst signals    = require('./utils/Signals').new();\n\nconst listeners   = {};\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'updatePointer', 'removePointer',\n];\n\n// for ignoring browser's simulated mouse events\nlet prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nclass Interaction {\n  /** */\n  constructor ({ pointerType }) {\n    this.target        = null; // current interactable being interacted with\n    this.element       = null; // the target element of the interactable\n\n    this.prepared      = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null,\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0,\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this._interacting    = false;\n    this._ending         = false;\n\n    this.pointerType = pointerType;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  pointerDown (pointer, event, eventTarget) {\n    const pointerIndex = this.updatePointer(pointer, event, true);\n\n    signals.fire('down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    });\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction;\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget);\n   *     }\n   * });\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {object} interact\n   */\n  start (action, target, element) {\n    if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (scope.interactions.indexOf(this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target         = target;\n    this.element        = element;\n\n    signals.fire('action-start', {\n      interaction: this,\n      event: this.downEvent,\n    });\n  }\n\n  pointerMove (pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer);\n      utils.setCoords(this.curCoords, this.pointers);\n    }\n\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                           && this.curCoords.page.y === this.prevCoords.page.y\n                           && this.curCoords.client.x === this.prevCoords.client.x\n                           && this.curCoords.client.y === this.prevCoords.client.y);\n\n    let dx;\n    let dy;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n    }\n\n    const signalArg = {\n      pointer,\n      pointerIndex: this.getPointerIndex(pointer),\n      event,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n      interactingBeforeMove: this.interacting(),\n    };\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n    }\n\n    signals.fire('move', signalArg);\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.doMove(signalArg);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }});\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.doMove();\n   *     }\n   *   });\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  doMove (signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this,\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('action-move', signalArg);\n    }\n\n    this._dontFireMove = false;\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.getPointerIndex(pointer);\n\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\n      pointer,\n      pointerIndex,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n    }\n\n    this.pointerIsDown = false;\n    this.removePointer(pointer, event);\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end();\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation();\n   *     }\n   *   });\n   * ```\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event) {\n    this._ending = true;\n\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event,\n        interaction: this,\n      });\n    }\n\n    this.stop();\n    this._ending = false;\n  }\n\n  currentAction () {\n    return this._interacting? this.prepared.name: null;\n  }\n\n  interacting () {\n    return this._interacting;\n  }\n\n  /** */\n  stop () {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\n    }\n\n    this.target = this.element = null;\n\n    this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  }\n\n  getPointerIndex (pointer) {\n    // mouse and pen interactions may have only one pointer\n    if (this.pointerType === 'mouse' || this.pointerType === 'pen') {\n      return 0;\n    }\n\n    return this.pointerIds.indexOf(utils.getPointerId(pointer));\n  }\n\n  updatePointer (pointer, event, down = event && /(down|start)$/i.test(event.type)) {\n    const id = utils.getPointerId(pointer);\n    let index = this.getPointerIndex(pointer);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n      this.pointerIds[index] = id;\n    }\n\n    if (down) {\n      signals.fire('update-pointer-down', {\n        pointer,\n        event,\n        down,\n        pointerId: id,\n        pointerIndex: index,\n        interaction: this,\n      });\n    }\n\n    this.pointers[index] = pointer;\n\n    return index;\n  }\n\n  removePointer (pointer, event) {\n    const index = this.getPointerIndex(pointer);\n\n    if (index === -1) { return; }\n\n    signals.fire('remove-pointer', {\n      pointer,\n      event,\n      pointerIndex: index,\n      interaction: this,\n    });\n\n    this.pointers   .splice(index, 1);\n    this.pointerIds .splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes  .splice(index, 1);\n  }\n\n  _updateEventTargets (target, currentTarget) {\n    this._eventTarget    = target;\n    this._curEventTarget = currentTarget;\n  }\n}\n\nfor (const method of methodNames) {\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions (method) {\n  return (function (event) {\n    const pointerType = utils.getPointerType(event);\n    const [eventTarget, curEventTarget] = utils.getEventTargets(event);\n    const matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch;\n        const interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction({ pointerType })]);\n      }\n    }\n    else {\n      let invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = scope.interactions[i].pointerType !== 'mouse' && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer\n          || (new Date().getTime() - prevTouchTime < 500)\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          || event.timeStamp === 0;\n      }\n\n      if (!invalidPointer) {\n        let interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n          interaction = new Interaction({ pointerType });\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (const [pointer, interaction] of matches) {\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  });\n}\n\nfunction endAll (event) {\n  for (const interaction of scope.interactions) {\n    interaction.end(event);\n    signals.fire('endall', { event, interaction });\n  }\n}\n\nconst docEvents = { /* 'eventType': listenerFunc */ };\nconst pEventTypes = browser.pEventTypes;\n\nif (domObjects.PointerEvent) {\n  docEvents[pEventTypes.down  ] = listeners.pointerDown;\n  docEvents[pEventTypes.move  ] = listeners.pointerMove;\n  docEvents[pEventTypes.up    ] = listeners.pointerUp;\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\n}\nelse {\n  docEvents.mousedown   = listeners.pointerDown;\n  docEvents.mousemove   = listeners.pointerMove;\n  docEvents.mouseup     = listeners.pointerUp;\n\n  docEvents.touchstart  = listeners.pointerDown;\n  docEvents.touchmove   = listeners.pointerMove;\n  docEvents.touchend    = listeners.pointerUp;\n  docEvents.touchcancel = listeners.pointerUp;\n}\n\ndocEvents.blur = endAll;\n\nfunction onDocSignal ({ doc }, signalName) {\n  const eventMethod = signalName.indexOf('add') === 0\n    ? events.add : events.remove;\n\n  // delegate event listener\n  for (const eventType in scope.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener);\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  for (const eventType in docEvents) {\n    eventMethod(doc, eventType, docEvents[eventType], browser.isIOS ? { passive: false } : undefined);\n  }\n}\n\nsignals.on('update-pointer-down', ({ interaction, pointer, pointerId, pointerIndex, event, eventTarget, down }) => {\n  interaction.pointerIds[pointerIndex] = pointerId;\n  interaction.pointers[pointerIndex] = pointer;\n\n  if (down) {\n    interaction.pointerIsDown = true;\n  }\n\n  if (!interaction.interacting()) {\n    utils.setCoords(interaction.startCoords, interaction.pointers);\n\n    utils.copyCoords(interaction.curCoords , interaction.startCoords);\n    utils.copyCoords(interaction.prevCoords, interaction.startCoords);\n\n    interaction.downEvent                 = event;\n    interaction.downTimes[pointerIndex]   = interaction.curCoords.timeStamp;\n    interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\n    interaction.pointerWasMoved           = false;\n\n    utils.pointerExtend(interaction.downPointer, pointer);\n  }\n});\n\nscope.signals.on('add-document'   , onDocSignal);\nscope.signals.on('remove-document', onDocSignal);\n\nInteraction.pointerMoveTolerance = 1;\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.endAll = endAll;\nInteraction.signals = signals;\nInteraction.docEvents = docEvents;\n\nscope.endAllInteractions = endAll;\n\nmodule.exports = Interaction;\n","const Interaction   = require('../Interaction');\nconst InteractEvent = require('../InteractEvent');\n\nconst actions = {\n  firePrepared,\n  names: [],\n  methodDict: {},\n};\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  interaction._interacting = true;\n  firePrepared(interaction, event, 'start');\n});\n\nInteraction.signals.on('action-move', function ({ interaction, event, preEnd }) {\n  firePrepared(interaction, event, 'move', preEnd);\n\n  // if the action was ended in a listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  firePrepared(interaction, event, 'end');\n});\n\nfunction firePrepared (interaction, event, phase, preEnd) {\n  const actionName = interaction.prepared.name;\n\n  const newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\n\n  interaction.target.fire(newEvent);\n  interaction.prevEvent = newEvent;\n}\n\nmodule.exports = actions;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drag = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  },\n\n  checker: function (pointer, event, interactable) {\n    const dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\n                               ? dragOptions.startAxis\n                               : dragOptions.lockAxis)}\n      : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n};\n\nInteraction.signals.on('before-action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy   = 0;\n  }\n  else if (axis === 'y') {\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx   = 0;\n  }\n});\n\n// dragmove\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'dragmove') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    iEvent.pageY   = interaction.startCoords.page.y;\n    iEvent.clientY = interaction.startCoords.client.y;\n    iEvent.dy = 0;\n  }\n  else if (axis === 'y') {\n    iEvent.pageX   = interaction.startCoords.page.x;\n    iEvent.clientX = interaction.startCoords.client.x;\n    iEvent.dx = 0;\n  }\n});\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * });\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nInteractable.prototype.draggable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.drag.enabled = options.enabled === false? false: true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.drag.enabled = options;\n\n    if (!options) {\n      this.ondragstart = this.ondragstart = this.ondragend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(Interactable.eventTypes, [\n  'dragstart',\n  'dragmove',\n  'draginertiastart',\n  'draginertiaresume',\n  'dragend',\n]);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst scope          = require('../scope');\n/** @lends module:interact */\nconst interact       = require('../interact');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drop = {\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  },\n};\n\nlet dynamicDrop = false;\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements  = [];\n  interaction.activeDrops.rects     = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction.activeDrops, interaction.element);\n  }\n\n  const dragEvent = interaction.prevEvent;\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction.activeDrops, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new', function ({ interaction, iEvent, event }) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\n\n  const draggableElement = interaction.element;\n  const dragEvent = iEvent;\n  const dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget  = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function ({ interaction }) {\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function ({ interaction }) {\n  interaction.activeDrops = {\n    dropzones: null,\n    elements: null,\n    rects: null,\n  };\n\n  interaction.dropEvents = null;\n});\n\nfunction collectDrops (activeDrops, element) {\n  const drops = [];\n  const elements = [];\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const current of scope.interactables) {\n    if (!current.options.drop.enabled) { continue; }\n\n    const accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if ((utils.is.element(accept) && accept !== element)\n        || (utils.is.string(accept)\n        && !utils.matchesSelector(element, accept))) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.is.string(current.target)\n      ? current._context.querySelectorAll(current.target)\n      : [current.target];\n\n    for (const currentElement of dropElements) {\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements,\n    dropzones: drops,\n  };\n}\n\nfunction fireActiveDrops (activeDrops, event) {\n  let prevElement;\n\n  // loop through all active dropzones and trigger event\n  for (let i = 0; i < activeDrops.dropzones.length; i++) {\n    const current = activeDrops.dropzones[i];\n    const currentElement = activeDrops.elements [i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops (activeDrops, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  const possibleDrops = collectDrops(activeDrops, dragElement);\n\n  activeDrops.dropzones = possibleDrops.dropzones;\n  activeDrops.elements  = possibleDrops.elements;\n  activeDrops.rects     = [];\n\n  for (let i = 0; i < activeDrops.dropzones.length; i++) {\n    activeDrops.rects[i] = activeDrops.dropzones[i].getRect(activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop (dragEvent, event, dragElement) {\n  const interaction = dragEvent.interaction;\n  const validDrops = [];\n\n  if (dynamicDrop) {\n    setActiveDrops(interaction.activeDrops, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    const current        = interaction.activeDrops.dropzones[j];\n    const currentElement = interaction.activeDrops.elements [j];\n    const rect           = interaction.activeDrops.rects    [j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\n      ? currentElement\n      : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element : interaction.activeDrops.elements [dropIndex] || null,\n  };\n}\n\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  };\n\n  const tmpl = {\n    dragEvent,\n    interaction,\n    target       : interaction.dropElement,\n    dropzone     : interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable    : dragEvent.interactable,\n    timeStamp    : dragEvent.timeStamp,\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent,\n        interaction,\n        target       : interaction.dropElement,\n        dropzone     : interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragenter',\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n    dragEvent.relatedTarget = interaction.dropElement;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target   = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target   = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove     : dragEvent,\n      type         : 'dropmove',\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents (interaction, dropEvents) {\n  const {\n    activeDrops,\n    prevDropTarget,\n    dropTarget,\n    dropElement,\n  } = interaction;\n\n  if (dropEvents.leave) { prevDropTarget.fire(dropEvents.leave); }\n  if (dropEvents.move ) {     dropTarget.fire(dropEvents.move ); }\n  if (dropEvents.enter) {     dropTarget.fire(dropEvents.enter); }\n  if (dropEvents.drop ) {     dropTarget.fire(dropEvents.drop ); }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(activeDrops, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget  = dropTarget;\n  interaction.prevDropElement = dropElement;\n}\n\n/**\n * ```js\n * interact(target)\n * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n *                       event,             // TouchEvent/PointerEvent/MouseEvent\n *                       dropped,           // bool result of the default checker\n *                       dropzone,          // dropzone Interactable\n *                       dropElement,       // dropzone elemnt\n *                       draggable,         // draggable Interactable\n *                       draggableElement) {// draggable element\n *\n *   return dropped && event.target.hasAttribute('allow-drop');\n * }\n * ```\n *\n * ```js\n * interact('.drop').dropzone({\n *   accept: '.can-drop' || document.getElementById('single-drop'),\n *   overlap: 'pointer' || 'center' || zeroToOne\n * }\n * ```\n *\n * Returns or sets whether draggables can be dropped onto this target to\n * trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged element\n * is over this Interactable.\n *\n * @param {boolean | object | null} [options] The new options to be set.\n * @return {boolean | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.dropzone = function (options) {\n  if (utils.is.object(options)) {\n    this.options.drop.enabled = options.enabled === false? false: true;\n\n    if (utils.is.function(options.ondrop)          ) { this.events.ondrop           = options.ondrop          ; }\n    if (utils.is.function(options.ondropactivate)  ) { this.events.ondropactivate   = options.ondropactivate  ; }\n    if (utils.is.function(options.ondropdeactivate)) { this.events.ondropdeactivate = options.ondropdeactivate; }\n    if (utils.is.function(options.ondragenter)     ) { this.events.ondragenter      = options.ondragenter     ; }\n    if (utils.is.function(options.ondragleave)     ) { this.events.ondragleave      = options.ondragleave     ; }\n    if (utils.is.function(options.ondropmove)      ) { this.events.ondropmove       = options.ondropmove      ; }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    }\n    else if (utils.is.number(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.drop.enabled = options;\n\n    if (!options) {\n      this.ondragenter = this.ondragleave = this.ondrop\n        = this.ondropactivate = this.ondropdeactivate = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  let dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return (this.options.drop.checker\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n      : false);\n  }\n\n  const dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n    const page = utils.getPageXY(dragEvent);\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right);\n    const vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n    dropped = horizontal && vertical;\n  }\n\n  const dragRect = draggable.getRect(draggableElement);\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2;\n    const cy = dragRect.top  + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (dragRect && utils.is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function ({ interactable }) {\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement     = null; // the element at the time of checking\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [],      // the dropzones that are mentioned below\n    elements : [],      // elements of dropzones that accept the target draggable\n    rects    : [],      // the rects of the elements mentioned above\n  };\n\n});\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  interaction.dropTarget = interaction.dropElement =\n    interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\n/**\n * Returns or sets whether the dimensions of dropzone elements are calculated\n * on every dragmove or only on dragstart for the default dropChecker\n *\n * @param {boolean} [newValue] True to check on each move. False to check only\n * before start\n * @return {boolean | interact} The current setting or interact\n */\ninteract.dynamicDrop = function (newValue) {\n  if (utils.is.bool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n    //}\n\n    dynamicDrop = newValue;\n\n    return interact;\n  }\n  return dynamicDrop;\n};\n\nutils.merge(Interactable.eventTypes, [\n  'dragenter',\n  'dragleave',\n  'dropactivate',\n  'dropdeactivate',\n  'dropmove',\n  'drop',\n]);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst gesture = {\n  defaults: {\n    enabled : false,\n    origin  : null,\n    restrict: null,\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n};\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturestart') { return; }\n  iEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.scale = 1;\n});\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturemove') { return; }\n\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(iEvent);\n\n  interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.prevDistance = iEvent.distance;\n\n  if (iEvent.scale !== Infinity\n      && iEvent.scale !== null\n      && iEvent.scale !== undefined\n      && !isNaN(iEvent.scale)) {\n\n    interaction.gesture.scale = iEvent.scale;\n  }\n});\n\n/**\n * ```js\n * interact(element).gesturable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // limit multiple gestures.\n *     // See the explanation in {@link Interactable.draggable} example\n *     max: Infinity,\n *     maxPerElement: 1,\n * });\n *\n * var isGestureable = interact(element).gesturable();\n * ```\n *\n * Gets or sets whether multitouch gestures can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on gesture events (makes the Interactable gesturable)\n * @return {boolean | Interactable} A boolean indicating if this can be the\n * target of gesture events, or this Interactable\n */\nInteractable.prototype.gesturable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.gesture.enabled = options.enabled === false? false: true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.is.bool(options)) {\n    this.options.gesture.enabled = options;\n\n    if (!options) {\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action, event, starting, ending, deltaSource }) {\n  if (action !== 'gesture') { return; }\n\n  const pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = 1;\n    iEvent.ds       = 0;\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da       = 0;\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box      = interaction.prevEvent.box;\n    iEvent.scale    = interaction.prevEvent.scale;\n    iEvent.ds       = iEvent.scale - 1;\n    iEvent.angle    = interaction.prevEvent.angle;\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\n  }\n  else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0,   // distance between two touches of touchStart\n    prevDistance : 0,\n    distance     : 0,\n\n    scale: 1,           // gesture.distance / gesture.startDistance\n\n    startAngle: 0,      // angle of line joining two touches\n    prevAngle : 0,      // angle of the previous gesture event\n  };\n});\n\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(Interactable.eventTypes, [\n  'gesturestart',\n  'gesturemove',\n  'gestureend',\n]);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n","const actions        = require('./base');\nconst utils          = require('../utils');\nconst browser        = require('../utils/browser');\nconst InteractEvent  = require('../InteractEvent');\n/** @lends Interactable */\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\n// Less Precision with touch input\nconst defaultMargin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\nconst resize = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) { return null; }\n\n    const page = utils.extend({}, interaction.curCoords.page);\n    const options = interactable.options;\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize;\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.is.object(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n                                              resizeOptions.edges[edge],\n                                              page,\n                                              interaction._eventTarget,\n                                              element,\n                                              rect,\n                                              resizeOptions.margin || defaultMargin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          };\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - defaultMargin);\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - defaultMargin);\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: (browser.isIe9 ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  }),\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    }\n    else if (action.edges) {\n      let cursorKey = '';\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n};\n\n// resizestart\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n    return;\n  }\n\n  const startRect = interaction.target.getRect(interaction.element);\n  const resizeOptions = interaction.target.options.resize;\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    const linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n    interaction.prepared._linkedEdges = linkedEdges;\n  }\n  else {\n    interaction.prepared._linkedEdges = null;\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n  }\n\n  interaction.resizeRects = {\n    start     : startRect,\n    current   : utils.extend({}, startRect),\n    inverted  : utils.extend({}, startRect),\n    previous  : utils.extend({}, startRect),\n    delta     : {\n      left: 0, right : 0, width : 0,\n      top : 0, bottom: 0, height: 0,\n    },\n  };\n\n  iEvent.rect = interaction.resizeRects.inverted;\n  iEvent.deltaRect = interaction.resizeRects.delta;\n});\n\n// resizemove\nInteractEvent.signals.on('new', function ({ iEvent, phase, interaction }) {\n  if (phase !== 'move' || !interaction.prepared.edges) { return; }\n\n  const resizeOptions = interaction.target.options.resize;\n  const invert = resizeOptions.invert;\n  const invertible = invert === 'reposition' || invert === 'negate';\n\n  let edges = interaction.prepared.edges;\n\n  const start      = interaction.resizeRects.start;\n  const current    = interaction.resizeRects.current;\n  const inverted   = interaction.resizeRects.inverted;\n  const delta      = interaction.resizeRects.delta;\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted);\n  const originalEdges = edges;\n\n  let dx = iEvent.dx;\n  let dy = iEvent.dy;\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    const startAspectRatio = resizeOptions.preserveAspectRatio\n      ? interaction.resizeStartAspectRatio\n      : 1;\n\n    edges = interaction.prepared._linkedEdges;\n\n    if ((originalEdges.left && originalEdges.bottom)\n        || (originalEdges.right && originalEdges.top)) {\n      dy = -dx / startAspectRatio;\n    }\n    else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\n    else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\n  }\n\n  // update the 'current' rect without modifications\n  if (edges.top   ) { current.top    += dy; }\n  if (edges.bottom) { current.bottom += dy; }\n  if (edges.left  ) { current.left   += dx; }\n  if (edges.right ) { current.right  += dx; }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current);\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      let swap;\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top;\n\n        inverted.top = inverted.bottom;\n        inverted.bottom = swap;\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left;\n\n        inverted.left = inverted.right;\n        inverted.right = swap;\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top    = Math.min(current.top, start.bottom);\n    inverted.bottom = Math.max(current.bottom, start.top);\n    inverted.left   = Math.min(current.left, start.right);\n    inverted.right  = Math.max(current.right, start.left);\n  }\n\n  inverted.width  = inverted.right  - inverted.left;\n  inverted.height = inverted.bottom - inverted.top ;\n\n  for (const edge in inverted) {\n    delta[edge] = inverted[edge] - previous[edge];\n  }\n\n  iEvent.edges = interaction.prepared.edges;\n  iEvent.rect = inverted;\n  iEvent.deltaRect = delta;\n});\n\n/**\n * ```js\n * interact(element).resizable({\n *   onstart: function (event) {},\n *   onmove : function (event) {},\n *   onend  : function (event) {},\n *\n *   edges: {\n *     top   : true,       // Use pointer coords to check for resize.\n *     left  : false,      // Disable resizing from left edge.\n *     bottom: '.resize-s',// Resize if pointer target matches selector\n *     right : handleEl    // Resize if pointer target is the given Element\n *   },\n *\n *     // Width and height can be adjusted independently. When `true`, width and\n *     // height are adjusted at a 1:1 ratio.\n *     square: false,\n *\n *     // Width and height can be adjusted independently. When `true`, width and\n *     // height maintain the aspect ratio they had when resizing started.\n *     preserveAspectRatio: false,\n *\n *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n *   // 'negate' will allow the rect to have negative width/height\n *   // 'reposition' will keep the width/height positive by swapping\n *   // the top and bottom edges and/or swapping the left and right edges\n *   invert: 'none' || 'negate' || 'reposition'\n *\n *   // limit multiple resizes.\n *   // See the explanation in the {@link Interactable.draggable} example\n *   max: Infinity,\n *   maxPerElement: 1,\n * });\n *\n * var isResizeable = interact(element).resizable();\n * ```\n *\n * Gets or sets whether resize actions can be performed on the target\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on resize events (object makes the Interactable\n * resizable)\n * @return {boolean | Interactable} A boolean indicating if this can be the\n * target of resize elements, or this Interactable\n */\nInteractable.prototype.resizable = function (options) {\n  if (utils.is.object(options)) {\n    this.options.resize.enabled = options.enabled === false? false: true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      this.options.resize.axis = defaultOptions.resize.axis;\n    }\n\n    if (utils.is.bool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    }\n    else if (utils.is.bool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.is.bool(options)) {\n    this.options.resize.enabled = options;\n\n    if (!options) {\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\n    }\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) { return false; }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.is.number(rect.width )? rect.width  : rect.right  - rect.left;\n    const height = utils.is.number(rect.height)? rect.height : rect.bottom - rect.top ;\n\n    if (width < 0) {\n      if      (name === 'left' ) { name = 'right'; }\n      else if (name === 'right') { name = 'left' ; }\n    }\n    if (height < 0) {\n      if      (name === 'top'   ) { name = 'bottom'; }\n      else if (name === 'bottom') { name = 'top'   ; }\n    }\n\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n  }\n\n  // the remaining checks require an element\n  if (!utils.is.element(element)) { return false; }\n\n  return utils.is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action }) {\n  if (action !== 'resize' || !interaction.resizeAxes) { return; }\n\n  const options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    }\n    else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(Interactable.eventTypes, [\n  'resizestart',\n  'resizemove',\n  'resizeinertiastart',\n  'resizeinertiaresume',\n  'resizeend',\n]);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n","const raf            = require('./utils/raf');\nconst getWindow      = require('./utils/window').getWindow;\nconst is             = require('./utils/is');\nconst domUtils       = require('./utils/domUtils');\nconst Interaction    = require('./Interaction');\nconst defaultOptions = require('./defaultOptions');\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    container: null,     // the item that is scrolled (Window or HTMLElement)\n    margin   : 60,\n    speed    : 300,      // the scroll speed in pixels per second\n  },\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(autoScroll.interaction.element);\n    const now = new Date().getTime();\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    const s = options.speed * dt;\n\n    if (s >= 1) {\n      if (is.window(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      }\n      else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop  += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    const options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function ({ interaction, pointer }) {\n    if (!(interaction.interacting()\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(interaction.element);\n\n    if (is.window(container)) {\n      left   = pointer.clientX < autoScroll.margin;\n      top    = pointer.clientY < autoScroll.margin;\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container);\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = (right ? 1: left? -1: 0);\n    autoScroll.y = (bottom? 1:  top? -1: 0);\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed  = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  },\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n","/** @lends Interactable */\nconst Interactable = require('../Interactable');\nconst actions      = require('../actions/base');\nconst is           = require('../utils/is');\nconst domUtils     = require('../utils/domUtils');\n\nconst { warnOnce } = require('../utils');\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/**\n * ```js\n * interact(element, { ignoreFrom: document.getElementById('no-action') });\n * // or\n * interact(element).ignoreFrom('input, textarea, a');\n * ```\n * @deprecated\n * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n * of it's parents match the given CSS selector or Element, no\n * drag/resize/gesture is started.\n *\n * Don't use this method. Instead set the `ignoreFrom` option for each action\n * or for `pointerEvents`\n *\n * @example\n * interact(targett)\n *   .draggable({\n *     ignoreFrom: 'input, textarea, a[href]'',\n *   })\n *   .pointerEvents({\n *     ignoreFrom: '[no-pointer]',\n *   });\n *\n * @param {string | Element | null} [newValue] a CSS selector string, an\n * Element or `null` to not ignore any elements\n * @return {string | Element | object} The current ignoreFrom value or this\n * Interactable\n */\nInteractable.prototype.ignoreFrom = warnOnce(function (newValue) {\n  return this._backCompatOption('ignoreFrom', newValue);\n}, 'Interactable.ignoreForm() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');\n\n/**\n * ```js\n *\n * @deprecated\n * A drag/resize/gesture is started only If the target of the `mousedown`,\n * `pointerdown` or `touchstart` event or any of it's parents match the given\n * CSS selector or Element.\n *\n * Don't use this method. Instead set the `allowFrom` option for each action\n * or for `pointerEvents`\n *\n * @example\n * interact(targett)\n *   .resizable({\n *     allowFrom: '.resize-handle',\n *   .pointerEvents({\n *     allowFrom: '.handle',,\n *   });\n *\n * @param {string | Element | null} [newValue] a CSS selector string, an\n * Element or `null` to allow from any element\n * @return {string | Element | object} The current allowFrom value or this\n * Interactable\n */\nInteractable.prototype.allowFrom = warnOnce(function (newValue) {\n  return this._backCompatOption('allowFrom', newValue);\n}, 'Interactable.allowForm() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');\n\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n  if (!ignoreFrom || !is.element(element)) { return false; }\n\n  if (is.string(ignoreFrom)) {\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n  }\n  else if (is.element(ignoreFrom)) {\n    return domUtils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n  if (!allowFrom) { return true; }\n\n  if (!is.element(element)) { return false; }\n\n  if (is.string(allowFrom)) {\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n  }\n  else if (is.element(allowFrom)) {\n    return domUtils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n  return (!this.testIgnore(options.ignoreFrom, interactableElement, eventTarget)\n    && this.testAllow(options.allowFrom, interactableElement, eventTarget));\n};\n\n/**\n * ```js\n * interact('.resize-drag')\n *   .resizable(true)\n *   .draggable(true)\n *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n *\n *   if (interact.matchesSelector(event.target, '.drag-handle') {\n *     // force drag with handle target\n *     action.name = drag;\n *   }\n *   else {\n *     // resize from the top and right edges\n *     action.name  = 'resize';\n *     action.edges = { top: true, right: true };\n *   }\n *\n *   return action;\n * });\n * ```\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n * @param {function | null} [checker] A function which takes a pointer event,\n * defaultAction string, interactable, element and interaction as parameters\n * and returns an object with name property 'drag' 'resize' or 'gesture' and\n * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n * props.\n * @return {Function | Interactable} The checker function or this Interactable\n */\nInteractable.prototype.actionChecker = function (checker) {\n  if (is.function(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/**\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n * @param {boolean} [newValue]\n * @return {boolean | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.styleCursor = function (newValue) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  const rect = this.getRect(element);\n  const buttons = event.buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[event.button];\n  let action = null;\n\n  for (const actionName of actions.names) {\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown\n        && /mouse|pointer/.test(interaction.pointerType)\n        && (buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\n","const interact       = require('../interact');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst actions        = require('../actions/base');\nconst defaultOptions = require('../defaultOptions');\nconst scope          = require('../scope');\nconst utils          = require('../utils');\nconst signals        = require('../utils/Signals').new();\n\nrequire('./InteractableMethods');\n\nconst autoStart = {\n  signals,\n  withinInteractionLimit,\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: Infinity,\n  defaults: {\n    perAction: {\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      allowFrom:  null,\n      ignoreFrom: null,\n\n      // only allow left button by default\n      // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n      mouseButtons: 1,\n    },\n  },\n  setActionDefaults: function (action) {\n    utils.extend(action.defaults, autoStart.defaults.perAction);\n  },\n  validateAction,\n};\n\n// set cursor style on mousedown\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\n// set cursor style on mousemove\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.pointerType !== 'mouse'\n      || interaction.pointerIsDown\n      || interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  const { interaction, event } = arg;\n\n  if (!interaction.pointerIsDown\n      || interaction.interacting()\n      || !interaction.pointerWasMoved\n      || !interaction.prepared.name) {\n    return;\n  }\n\n  signals.fire('before-start', arg);\n\n  const target = interaction.target;\n\n  if (interaction.prepared.name && target) {\n    // check manualStart and interaction limit\n    if (target.options[interaction.prepared.name].manualStart\n        || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n      interaction.stop(event);\n    }\n    else {\n      interaction.start(interaction.prepared, target, interaction.element);\n    }\n  }\n});\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable, element, eventTarget) {\n  if (utils.is.object(action)\n      && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget)\n      && interactable.options[action.name].enabled\n      && withinInteractionLimit(interactable, element, action)) {\n    return action;\n  }\n\n  return null;\n}\n\nfunction validateSelector (interaction, pointer, event, matches, matchElements, eventTarget) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i];\n    const matchElement = matchElements[i];\n    const action = validateAction(match.getAction(pointer, event, interaction, matchElement),\n                                  match,\n                                  matchElement,\n                                  eventTarget);\n\n    if (action) {\n      return {\n        action,\n        target: match,\n        element: matchElement,\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\n  let matches = [];\n  let matchElements = [];\n\n  let element = eventTarget;\n\n  function pushMatches (interactable) {\n    matches.push(interactable);\n    matchElements.push(element);\n  }\n\n  while (utils.is.element(element)) {\n    matches = [];\n    matchElements = [];\n\n    scope.interactables.forEachMatch(element, pushMatches);\n\n    const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n\n    if (actionInfo.action\n      && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n      return actionInfo;\n    }\n\n    element = utils.parentNode(element);\n  }\n\n  return {};\n}\n\nfunction prepare (interaction, { action, target, element }) {\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    const cursor = action? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  const target = interaction.target;\n\n  if (target && target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nfunction withinInteractionLimit (interactable, element, action) {\n  const options = interactable.options;\n  const maxActions = options[action.name].max;\n  const maxPerElement = options[action.name].maxPerElement;\n  let activeInteractions = 0;\n  let targetCount = 0;\n  let targetElementCount = 0;\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) { return; }\n\n  for (const interaction of scope.interactions) {\n    const otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) { continue; }\n\n    activeInteractions++;\n\n    if (activeInteractions >= autoStart.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) { continue; }\n\n    targetCount += (otherAction === action.name)|0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return autoStart.maxInteractions > 0;\n}\n\n/**\n * Returns or sets the maximum number of concurrent interactions allowed.  By\n * default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables and\n * elements, you need to enable it in the draggable, resizable and gesturable\n * `'max'` and `'maxPerElement'` options.\n *\n * @alias module:interact.maxInteractions\n *\n * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n */\ninteract.maxInteractions = function (newValue) {\n  if (utils.is.number(newValue)) {\n    autoStart.maxInteractions = newValue;\n\n    return interact;\n  }\n\n  return autoStart.maxInteractions;\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.styleCursor = true;\n\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n\nmodule.exports = autoStart;\n","const autoStart = require('./base');\nconst scope     = require('../scope');\nconst is        = require('../utils/is');\n\nconst { parentNode } = require('../utils/domUtils');\n\nautoStart.setActionDefaults(require('../actions/drag'));\n\nautoStart.signals.on('before-start',  function ({ interaction, eventTarget, dx, dy }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx);\n  const absY = Math.abs(dy);\n  const targetOptions = interaction.target.options.drag;\n  const startAxis = targetOptions.startAxis;\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n  interaction.prepared.axis = targetOptions.lockAxis === 'start'\n    ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n    : targetOptions.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget;\n\n    const getDraggable = function (interactable) {\n      if (interactable === interaction.target) { return; }\n\n      const options = interaction.target.options.drag;\n\n      if (!options.manualStart\n          && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n        const action = interactable.getAction(\n          interaction.downPointer, interaction.downEvent, interaction, element);\n\n        if (action\n            && action.name === 'drag'\n            && checkStartAxis(currentAxis, interactable)\n            && autoStart.validateAction(action, interactable, element, eventTarget)) {\n\n          return interactable;\n        }\n      }\n    };\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable);\n\n      if (interactable) {\n        interaction.prepared.name = 'drag';\n        interaction.target = interactable;\n        interaction.element = element;\n        break;\n      }\n\n      element = parentNode(element);\n    }\n  }\n});\n\nfunction checkStartAxis (startAxis, interactable) {\n  if (!interactable) { return false; }\n\n  const thisAxis = interactable.options.drag.startAxis;\n\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\n}\n","require('./base').setActionDefaults(require('../actions/gesture'));\n","const autoStart   = require('./base');\nconst Interaction = require('../Interaction');\n\nautoStart.defaults.perAction.hold = 0;\nautoStart.defaults.perAction.delay = 0;\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.autoStartHoldTimer = null;\n});\n\nautoStart.signals.on('prepared', function ({ interaction }) {\n  const hold = getHoldDuration(interaction);\n\n  if (hold > 0) {\n    interaction.autoStartHoldTimer = setTimeout(() => {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, hold);\n  }\n});\n\nInteraction.signals.on('move', function ({ interaction, duplicate }) {\n  if (interaction.pointerWasMoved && !duplicate) {\n    clearTimeout(interaction.autoStartHoldTimer);\n  }\n});\n\n// prevent regular down->move autoStart\nautoStart.signals.on('before-start', function ({ interaction }) {\n  const hold = getHoldDuration(interaction);\n\n  if (hold > 0) {\n    interaction.prepared.name = null;\n  }\n});\n\nfunction getHoldDuration (interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name;\n\n  if (!actionName) { return null; }\n\n  const options = interaction.target.options;\n\n  return options[actionName].hold || options[actionName].delay;\n}\n\nmodule.exports = {\n  getHoldDuration,\n};\n","require('./base').setActionDefaults(require('../actions/resize'));\n","module.exports = {\n  base: {\n    accept        : null,\n    preventDefault: 'auto',\n    deltaSource   : 'page',\n  },\n\n  perAction: {\n    origin: { x: 0, y: 0 },\n\n    inertia: {\n      enabled          : false,\n      resistance       : 10,    // the lambda in exponential decay\n      minSpeed         : 100,   // target speed must be above this for inertia to start\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n      allowResume      : true,  // allow resuming an action in inertia phase\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n    },\n  },\n};\n","/* browser entry point */\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// pointerEvents\nrequire('./pointerEvents/base');\nrequire('./pointerEvents/holdRepeat');\nrequire('./pointerEvents/interactableTargets');\n\n// autoStart hold\nrequire('./autoStart/hold');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// load these modifiers after resize is loaded\nrequire('./modifiers/snapSize');\nrequire('./modifiers/restrictEdges');\nrequire('./modifiers/restrictSize');\n\n// autoStart actions\nrequire('./autoStart/gesture');\nrequire('./autoStart/resize');\nrequire('./autoStart/drag');\n\n// Interactable preventDefault setting\nrequire('./interactablePreventDefault.js');\n\n// autoScroll\nrequire('./autoScroll');\n\n// export interact\nmodule.exports = require('./interact');\n","const InteractEvent  = require('./InteractEvent');\nconst Interaction    = require('./Interaction');\nconst modifiers      = require('./modifiers/base');\nconst utils          = require('./utils');\nconst animationFrame = require('./utils/raf');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active     : false,\n    smoothEnd  : false,\n    allowResume: false,\n\n    startEvent: null,\n    upCoords  : {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i  : null,\n  };\n\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\n});\n\nInteraction.signals.on('down', function ({ interaction, event, pointer, eventTarget }) {\n  const status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    let element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.is.element(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        animationFrame.cancel(status.i);\n        status.active = false;\n        interaction.simulation = null;\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer);\n        utils.setCoords(interaction.curCoords, interaction.pointers);\n\n        // fire appropriate signals\n        const signalArg = { interaction };\n        Interaction.signals.fire('before-action-move', signalArg);\n        Interaction.signals.fire('action-resume'     , signalArg);\n\n        // fire a reume event\n        const resumeEvent = new InteractEvent(interaction,\n                                              event,\n                                              interaction.prepared.name,\n                                              'inertiaresume',\n                                              interaction.element);\n\n        interaction.target.fire(resumeEvent);\n        interaction.prevEvent = resumeEvent;\n        modifiers.resetStatuses(interaction.modifierStatuses);\n\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n        break;\n      }\n\n      element = utils.parentNode(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function ({ interaction, event }) {\n  const status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) { return; }\n\n  const target = interaction.target;\n  const options = target && target.options;\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  const now = new Date().getTime();\n  const statuses = {};\n  const page = utils.extend({}, interaction.curCoords.page);\n  const pointerSpeed = interaction.pointerDelta.client.speed;\n\n  let smoothEnd = false;\n  let modifierResult;\n\n  // check if inertia should be started\n  const inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                     && interaction.prepared.name !== 'gesture'\n                     && event !== status.startEvent);\n\n  const inertia = (inertiaPossible\n    && (now - interaction.curCoords.timeStamp) < 50\n    && pointerSpeed > inertiaOptions.minSpeed\n    && pointerSpeed > inertiaOptions.endSpeed);\n\n  const modifierArg = {\n    interaction,\n    pageCoords: page,\n    statuses,\n    preEnd: true,\n    requireEndOnly: true,\n  };\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) { return; }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent =\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  }\n  else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function ({ interaction }) {\n  const status = interaction.inertiaStatus;\n\n  if (status.active) {\n    animationFrame.cancel(status.i);\n    status.active = false;\n    interaction.simulation = null;\n  }\n});\n\nfunction calcInertia (interaction, status) {\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  const lambda = inertiaOptions.resistance;\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame () {\n  updateInertiaCoords(this);\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  const status = this.inertiaStatus;\n  const options = this.target.options[this.prepared.name].inertia;\n  const lambda = options.resistance;\n  const t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    }\n    else {\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\n                                                     status.xe,\n                                                     status.ye,\n                                                     status.modifiedXe,\n                                                     status.modifiedYe,\n                                                     progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  }\n  else {\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame () {\n  updateInertiaCoords(this);\n\n  const status = this.inertiaStatus;\n  const t = new Date().getTime() - status.t0;\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  }\n  else {\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd =\n      status.active = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords (interaction) {\n  const status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) { return; }\n\n  const pageUp   = status.upCoords.page;\n  const clientUp = status.upCoords.client;\n\n  utils.setCoords(interaction.curCoords, [ {\n    pageX  : pageUp.x   + status.sx,\n    pageY  : pageUp.y   + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy,\n  } ]);\n}\n","/** @module interact */\n\nconst browser      = require('./utils/browser');\nconst events       = require('./utils/events');\nconst utils        = require('./utils');\nconst scope        = require('./scope');\nconst Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\n\nconst globalEvents = {};\n\n/**\n * ```js\n * interact('#draggable').draggable(true);\n *\n * var rectables = interact('rect');\n * rectables\n *   .gesturable(true)\n *   .on('gesturemove', function (event) {\n *       // ...\n *   });\n * ```\n *\n * The methods of this variable can be used to set elements as interactables\n * and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to configure\n * it.\n *\n * @global\n *\n * @param {Element | string} element The HTML or SVG Element to interact with\n * or CSS selector\n * @return {Interactable}\n */\nfunction interact (element, options) {\n  let interactable = scope.interactables.get(element, options);\n\n  if (!interactable) {\n    interactable = new Interactable(element, options);\n    interactable.events.global = globalEvents;\n  }\n\n  return interactable;\n}\n\n/**\n * Check if an element or selector has been set with the {@link interact}\n * function\n *\n * @alias module:interact.isSet\n *\n * @param {Element} element The Element being searched for\n * @return {boolean} Indicates if the element or CSS selector was previously\n * passed to interact\n*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/**\n * Add a global listener for an InteractEvent or adds a DOM event to `document`\n *\n * @alias module:interact.on\n *\n * @param {string | array | object} type The types of events to listen for\n * @param {function} listener The function event (s)\n * @param {object | boolean} [options] object or useCapture flag for\n * addEventListener\n * @return {object} interact\n */\ninteract.on = function (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.on(eventType, listener, options);\n    }\n\n    return interact;\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(Interactable.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener];\n    }\n    else {\n      globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener, { options });\n  }\n\n  return interact;\n};\n\n/**\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n * @alias module:interact.off\n *\n * @param {string | array | object} type The types of events that were listened\n * for\n * @param {function} listener The listener function to be removed\n * @param {object | boolean} options [options] object or useCapture flag for\n * removeEventListener\n * @return {object} interact\n */\ninteract.off = function (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, options);\n    }\n\n    return interact;\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(Interactable.eventTypes, type)) {\n    events.remove(scope.document, type, listener, options);\n  }\n  else {\n    let index;\n\n    if (type in globalEvents\n        && (index = globalEvents[type].indexOf(listener)) !== -1) {\n      globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/**\n * Returns an object which exposes internal data\n\n * @alias module:interact.debug\n *\n * @return {object} An object with properties that outline the current state\n * and expose internal functions and variables\n */\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointerAverage;\ninteract.getTouchBBox       = utils.touchBBox;\ninteract.getTouchDistance   = utils.touchDistance;\ninteract.getTouchAngle      = utils.touchAngle;\n\ninteract.getElementRect       = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector      = utils.matchesSelector;\ninteract.closest              = utils.closest;\n\n/**\n * @alias module:interact.supportsTouch\n *\n * @return {boolean} Whether or not the browser supports touch input\n */\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/**\n * @alias module:interact.supportsPointerEvent\n *\n * @return {boolean} Whether or not the browser supports PointerEvents\n */\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/**\n * Cancels all interactions (end events are not fired)\n *\n * @alias module:interact.stop\n *\n * @param {Event} event An event on which to call preventDefault()\n * @return {object} interact\n */\ninteract.stop = function (event) {\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/**\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n * @alias module:interact.pointerMoveTolerance\n *\n * @param {number} [newValue] The movement from the start position must be greater than this value\n * @return {interact | number}\n */\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.is.number(newValue)) {\n    Interaction.pointerMoveTolerance = newValue;\n\n    return interact;\n  }\n\n  return Interaction.pointerMoveTolerance;\n};\n\ninteract.addDocument    = scope.addDocument;\ninteract.removeDocument = scope.removeDocument;\n\nscope.interact = interact;\n\nmodule.exports = interact;\n","const Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\nconst scope        = require('./scope');\nconst is           = require('./utils/is');\nconst events       = require('./utils/events');\nconst browser      = require('./utils/browser');\n\nconst { nodeContains, matchesSelector } = require('./utils/domUtils');\n\n/**\n * Returns or sets whether to prevent the browser's default behaviour in\n * response to pointer events. Can be set to:\n *  - `'always'` to always prevent\n *  - `'never'` to never prevent\n *  - `'auto'` to let interact.js try to determine what would be best\n *\n * @param {string} [newValue] `true`, `false` or `'auto'`\n * @return {string | Interactable} The current setting or this Interactable\n */\nInteractable.prototype.preventDefault = function (newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue;\n    return this;\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue? 'always' : 'never';\n    return this;\n  }\n\n  return this.options.preventDefault;\n};\n\nInteractable.prototype.checkAndPreventDefault = function (event) {\n  const setting = this.options.preventDefault;\n\n  if (setting === 'never') { return; }\n\n  if (setting === 'always') {\n    event.preventDefault();\n    return;\n  }\n\n  // setting === 'auto'\n\n  // don't preventDefault of touch{start,move} events if the browser supports passive\n  // events listeners. CSS touch-action and user-selecct should be used instead\n  if (events.supportsPassive\n    && /^touch(start|move)$/.test(event.type)\n    && !browser.isIOS) {\n    return;\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return;\n  }\n\n  // don't preventDefault on editable elements\n  if (is.element(event.target)\n      && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return;\n  }\n\n  event.preventDefault();\n};\n\nfunction onInteractionEvent ({ interaction, event }) {\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event);\n  }\n}\n\nfor (const eventSignal of ['down', 'move', 'up', 'cancel']) {\n  Interaction.signals.on(eventSignal, onInteractionEvent);\n}\n\n// prevent native HTML5 drag on interact.js target elements\nInteraction.docEvents.dragstart = function preventNativeDrag (event) {\n  for (const interaction of scope.interactions) {\n\n    if (interaction.element\n        && (interaction.element === event.target\n            || nodeContains(interaction.element, event.target))) {\n\n      interaction.target.checkAndPreventDefault(event);\n      return;\n    }\n  }\n};\n","const InteractEvent = require('../InteractEvent');\nconst Interaction   = require('../Interaction');\nconst extend        = require('../utils/extend');\n\nconst modifiers = {\n  names: [],\n\n  setOffsets: function (arg) {\n    const { interaction, pageCoords: page } = arg;\n    const { target, element, startOffset } = interaction;\n    const rect = target.getRect(element);\n\n    if (rect) {\n      startOffset.left = page.x - rect.left;\n      startOffset.top  = page.y - rect.top;\n\n      startOffset.right  = rect.right  - page.x;\n      startOffset.bottom = rect.bottom - page.y;\n\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\n    }\n    else {\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n    }\n\n    arg.rect = rect;\n    arg.interactable = target;\n    arg.element = element;\n\n    for (const modifierName of modifiers.names) {\n      arg.options = target.options[interaction.prepared.name][modifierName];\n\n      if (!arg.options) {\n        continue;\n      }\n\n      interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\n    }\n  },\n\n  setAll: function (arg) {\n    const { interaction, statuses, preEnd, requireEndOnly } = arg;\n    const result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true,\n    };\n\n    arg.modifiedCoords = extend({}, arg.pageCoords);\n\n    for (const modifierName of modifiers.names) {\n      const modifier = modifiers[modifierName];\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!shouldDo(options, preEnd, requireEndOnly)) { continue; }\n\n      arg.status = arg.status = statuses[modifierName];\n      arg.options = options;\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\n\n      modifier.set(arg);\n\n      if (arg.status.locked) {\n        arg.modifiedCoords.x += arg.status.dx;\n        arg.modifiedCoords.y += arg.status.dy;\n\n        result.dx += arg.status.dx;\n        result.dy += arg.status.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if:\n    //  - there are no modifiers enabled,\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n    //  - the locked coords have changed since the last pointer move\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (const modifierName of modifiers.names) {\n      const status = statuses[modifierName] || {};\n\n      status.dx = status.dy = 0;\n      status.modifiedX = status.modifiedY = NaN;\n      status.locked = false;\n      status.changed = true;\n\n      statuses[modifierName] = status;\n    }\n\n    return statuses;\n  },\n\n  start: function ({ interaction }, signalName) {\n    const arg = {\n      interaction,\n      pageCoords: (signalName === 'action-resume' ?\n                   interaction.curCoords : interaction.startCoords).page,\n      startOffset: interaction.startOffset,\n      statuses: interaction.modifierStatuses,\n      preEnd: false,\n      requireEndOnly: false,\n    };\n\n    modifiers.setOffsets(arg);\n    modifiers.resetStatuses(arg.statuses);\n\n    arg.pageCoords = extend({}, interaction.startCoords.page);\n    interaction.modifierResult = modifiers.setAll(arg);\n  },\n\n  beforeMove: function ({ interaction, preEnd, interactingBeforeMove }) {\n    const modifierResult = modifiers.setAll({\n      interaction,\n      preEnd,\n      pageCoords: interaction.curCoords.page,\n      statuses: interaction.modifierStatuses,\n      requireEndOnly: false,\n    });\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (!modifierResult.shouldMove && interactingBeforeMove) {\n      interaction._dontFireMove = true;\n    }\n\n    interaction.modifierResult = modifierResult;\n  },\n\n  end: function ({ interaction, event }) {\n    for (const modifierName of modifiers.names) {\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      // if the endOnly option is true for any modifier\n      if (shouldDo(options, true, true)) {\n        // fire a move event at the modified coordinates\n        interaction.doMove({ event, preEnd: true });\n        break;\n      }\n    }\n  },\n\n  setXY: function (arg) {\n    const { iEvent, interaction } = arg;\n    const modifierArg = extend({}, arg);\n\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n      modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!modifierArg.options) {\n        continue;\n      }\n\n      const modifier = modifiers[modifierName];\n\n      modifierArg.status = interaction.modifierStatuses[modifierName];\n\n      iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n    }\n  },\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets  = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n  interaction.modifierResult   = null;\n});\n\nInteraction.signals.on('action-start' , modifiers.start);\nInteraction.signals.on('action-resume', modifiers.start);\nInteraction.signals.on('before-action-move', modifiers.beforeMove);\nInteraction.signals.on('action-end', modifiers.end);\n\nInteractEvent.signals.on('set-xy', modifiers.setXY);\n\nfunction shouldDo (options, preEnd, requireEndOnly) {\n  return (options && options.enabled\n          && (preEnd || !options.endOnly)\n          && (!requireEndOnly || options.endOnly));\n}\n\nmodule.exports = modifiers;\n","const modifiers      = require('./base');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst restrict = {\n  defaults: {\n    enabled    : false,\n    endOnly    : false,\n    restriction: null,\n    elementRect: null,\n  },\n\n  setOffset: function ({ rect, startOffset, options }) {\n    const elementRect = options && options.elementRect;\n    const offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\n\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\n    }\n    else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function ({ modifiedCoords, interaction, status, options }) {\n    if (!options) { return status; }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, modifiedCoords);\n\n    const restriction = getRestrictionRect(options.restriction, interaction, page);\n\n    if (!restriction) { return status; }\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    const rect = restriction;\n    let modifiedX = page.x;\n    let modifiedY = page.y;\n\n    const offset = interaction.modifierOffsets.restrict;\n\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    if ('x' in restriction && 'y' in restriction) {\n      modifiedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\n      modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\n    }\n    else {\n      modifiedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\n      modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const elementRect = options && options.elementRect;\n\n    if (options && options.enabled\n        && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n\n  getRestrictionRect,\n};\n\nfunction getRestrictionRect (value, interaction, page) {\n  if (utils.is.function(value)) {\n    return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\n  } else {\n    return utils.resolveRectLike(value, interaction.target, interaction.element);\n  }\n}\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// });\n\nconst modifiers      = require('./base');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst { getRestrictionRect } = require('./restrict');\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity };\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity };\n\nconst restrictEdges = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n    offset: null,\n  },\n\n  setOffset: function ({ interaction, startOffset, options }) {\n    if (!options) {\n      return utils.extend({}, startOffset);\n    }\n\n    const offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\n\n    if (offset) {\n      return {\n        top:    startOffset.top    + offset.y,\n        left:   startOffset.left   + offset.x,\n        bottom: startOffset.bottom + offset.y,\n        right:  startOffset.right  + offset.x,\n      };\n    }\n\n    return startOffset;\n  },\n\n  set: function ({ modifiedCoords, interaction, status, offset, options }) {\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, modifiedCoords);\n    const inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\n    const outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\n\n    let modifiedX = page.x;\n    let modifiedY = page.y;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (edges.top) {\n      modifiedY = Math.min(Math.max(outer.top    + offset.top,    page.y), inner.top    + offset.top);\n    }\n    else if (edges.bottom) {\n      modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\n    }\n    if (edges.left) {\n      modifiedX = Math.min(Math.max(outer.left   + offset.left,   page.x), inner.left   + offset.left);\n    }\n    else if (edges.right) {\n      modifiedX = Math.max(Math.min(outer.right  - offset.right,  page.x), inner.right  - offset.right);\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    if (options && options.enabled\n        && !(phase === 'start' && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n\n  noInner,\n  noOuter,\n  getRestrictionRect,\n};\n\nmodifiers.restrictEdges = restrictEdges;\nmodifiers.names.push('restrictEdges');\n\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\nresize.defaults.restrictEdges          = restrictEdges.defaults;\n\nmodule.exports = restrictEdges;\n","// This module adds the options.resize.restrictSize setting which sets min and\n// max width and height for the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictSize: {\n//     min: { width: -600, height: -600 },\n//     max: { width:  600, height:  600 },\n//   },\n// });\n\nconst modifiers      = require('./base');\nconst restrictEdges  = require('./restrictEdges');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst noMin = { width: -Infinity, height: -Infinity };\nconst noMax = { width: +Infinity, height: +Infinity };\n\nconst restrictSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n  },\n\n  setOffset: function ({ interaction }) {\n    return interaction.startOffset;\n  },\n\n  set: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n\n    const minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n    const maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n\n    arg.options = {\n      enabled: options.enabled,\n      endOnly: options.endOnly,\n      inner: utils.extend({}, restrictEdges.noInner),\n      outer: utils.extend({}, restrictEdges.noOuter),\n    };\n\n    if (edges.top) {\n      arg.options.inner.top = rect.bottom - minSize.height;\n      arg.options.outer.top = rect.bottom - maxSize.height;\n    }\n    else if (edges.bottom) {\n      arg.options.inner.bottom = rect.top + minSize.height;\n      arg.options.outer.bottom = rect.top + maxSize.height;\n    }\n    if (edges.left) {\n      arg.options.inner.left = rect.right - minSize.width;\n      arg.options.outer.left = rect.right - maxSize.width;\n    }\n    else if (edges.right) {\n      arg.options.inner.right = rect.left + minSize.width;\n      arg.options.outer.right = rect.left + maxSize.width;\n    }\n\n    restrictEdges.set(arg);\n  },\n\n  modifyCoords: restrictEdges.modifyCoords,\n};\n\nmodifiers.restrictSize = restrictSize;\nmodifiers.names.push('restrictSize');\n\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\nresize.defaults.restrictSize          = restrictSize.defaults;\n\nmodule.exports = restrictSize;\n","const modifiers      = require('./base');\nconst interact       = require('../interact');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null,\n  },\n\n  setOffset: function ({ interaction, interactable, element, rect, startOffset, options }) {\n    const offsets = [];\n    const optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\n    const origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n    options = options || interactable.options[interaction.prepared.name].snap || {};\n\n    let snapOffset;\n\n    if (options.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y,\n      };\n    }\n    else  {\n      const offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\n\n      snapOffset = utils.rectToXY(offsetRect) || { x: 0, y: 0 };\n    }\n\n    if (rect && options.relativePoints && options.relativePoints.length) {\n      for (const { x: relativeX, y: relativeY } of options.relativePoints) {\n        offsets.push({\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\n        });\n      }\n    }\n    else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function ({ interaction, modifiedCoords, status, options, offset: offsets }) {\n    const targets = [];\n    let target;\n    let page;\n    let i;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    }\n    else {\n      const origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n\n      page = utils.extend({}, modifiedCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    let len = options.targets? options.targets.length : 0;\n\n    for (const { x: offsetX, y: offsetY } of offsets) {\n      const relativeX = page.x - offsetX;\n      const relativeY = page.y - offsetY;\n\n      for (const snapTarget of (options.targets || [])) {\n        if (utils.is.function(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        }\n        else {\n          target = snapTarget;\n        }\n\n        if (!target) { continue; }\n\n        targets.push({\n          x: utils.is.number(target.x) ? (target.x + offsetX) : relativeX,\n          y: utils.is.number(target.y) ? (target.y + offsetY) : relativeY,\n\n          range: utils.is.number(target.range)? target.range: options.range,\n        });\n      }\n    }\n\n    const closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0,\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      const range = target.range;\n      const dx = target.x - page.x;\n      const dy = target.y - page.y;\n      const distance = utils.hypot(dx, dy);\n      let inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n          // the pointer is relatively deeper in this target\n          ? distance / range < closest.distance / closest.range\n          // this target has Infinite range and the closest doesn't\n          : (range === Infinity && closest.range !== Infinity)\n          // OR this target is closer that the previous closest\n        || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    let snapChanged;\n\n    if (closest.target) {\n      snapChanged = (status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y);\n\n      status.modifiedX = closest.target.x;\n      status.modifiedY = closest.target.y;\n    }\n    else {\n      snapChanged = true;\n\n      status.modifiedX = NaN;\n      status.modifiedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\n    status.locked = closest.inRange;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const relativePoints = options && options.relativePoints;\n\n    if (options && options.enabled\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range  : status.range,\n        locked : status.locked,\n        x      : status.modifiedX,\n        y      : status.modifiedY,\n        realX  : status.realX,\n        realY  : status.realY,\n        dx     : status.dx,\n        dy     : status.dy,\n      };\n    }\n  },\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    const limits = grid.limits || {\n      left  : -Infinity,\n      right :  Infinity,\n      top   : -Infinity,\n      bottom:  Infinity,\n    };\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (utils.is.object(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    const gridx = Math.round((x - offsetX) / grid.x);\n    const gridy = Math.round((y - offsetY) / grid.y);\n\n    const newX = Math.max(limits.left, Math.min(limits.right , gridx * grid.x + offsetX));\n    const newY = Math.max(limits.top , Math.min(limits.bottom, gridy * grid.y + offsetY));\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range,\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nconst modifiers      = require('./base');\nconst snap           = require('./snap');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\nconst utils          = require('../utils/');\n\nconst snapSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n  },\n\n  setOffset: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.edges;\n\n    if (!edges) { return; }\n\n    arg.options = {\n      relativePoints: [{\n        x: edges.left? 0 : 1,\n        y: edges.top ? 0 : 1,\n      }],\n      origin: { x: 0, y: 0 },\n      offset: 'self',\n      range: options.range,\n    };\n\n    const offsets = snap.setOffset(arg);\n    arg.options = options;\n\n    return offsets;\n  },\n\n  set: function (arg) {\n    const { interaction, options, offset, modifiedCoords } = arg;\n    const page = utils.extend({}, modifiedCoords);\n    const relativeX = page.x - offset[0].x;\n    const relativeY = page.y - offset[0].y;\n\n    arg.options = utils.extend({}, options);\n    arg.options.targets = [];\n\n    for (const snapTarget of (options.targets || [])) {\n      let target;\n\n      if (utils.is.function(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction);\n      }\n      else {\n        target = snapTarget;\n      }\n\n      if (!target) { continue; }\n\n      if ('width' in target && 'height' in target) {\n        target.x = target.width;\n        target.y = target.height;\n      }\n\n      arg.options.targets.push(target);\n    }\n\n    snap.set(arg);\n  },\n\n  modifyCoords: function (arg) {\n    const { options } = arg;\n\n    arg.options = utils.extend({}, options);\n    arg.options.enabled = options.enabled;\n    arg.options.relativePoints = [null];\n\n    snap.modifyCoords(arg);\n  },\n};\n\nmodifiers.snapSize = snapSize;\nmodifiers.names.push('snapSize');\n\ndefaultOptions.perAction.snapSize = snapSize.defaults;\nresize.defaults.snapSize          = snapSize.defaults;\n\nmodule.exports = snapSize;\n","const pointerUtils = require('../utils/pointerUtils');\n\nmodule.exports = class PointerEvent {\n  /** */\n  constructor (type, pointer, event, eventTarget, interaction) {\n    pointerUtils.pointerExtend(this, event);\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer);\n    }\n\n    this.interaction = interaction;\n\n    this.timeStamp     = new Date().getTime();\n    this.originalEvent = event;\n    this.type          = type;\n    this.pointerId     = pointerUtils.getPointerId(pointer);\n    this.pointerType   = pointerUtils.getPointerType(pointer);\n    this.target        = eventTarget;\n    this.currentTarget = null;\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer);\n      this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\n\n      const interval = this.timeStamp - interaction.tapTime;\n\n      this.double = !!(interaction.prevTap\n        && interaction.prevTap.type !== 'doubletap'\n        && interaction.prevTap.target === this.target\n        && interval < 500);\n    }\n    else if (type === 'doubletap') {\n      this.dt = pointer.timeStamp - interaction.tapTime;\n    }\n  }\n\n  subtractOrigin ({ x: originX, y: originY }) {\n    this.pageX   -= originX;\n    this.pageY   -= originY;\n    this.clientX -= originX;\n    this.clientY -= originY;\n\n    return this;\n  }\n\n  addOrigin ({ x: originX, y: originY }) {\n    this.pageX   += originX;\n    this.pageY   += originY;\n    this.clientX += originX;\n    this.clientY += originY;\n\n    return this;\n  }\n\n  /** */\n  preventDefault () {\n    this.originalEvent.preventDefault();\n  }\n\n  /** */\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n\n  /** */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n};\n","const PointerEvent = require('./PointerEvent');\nconst Interaction  = require('../Interaction');\nconst utils        = require('../utils');\nconst defaults     = require('../defaultOptions');\nconst signals      = require('../utils/Signals').new();\n\nconst simpleSignals = [ 'down', 'up', 'cancel' ];\nconst simpleEvents  = [ 'down', 'up', 'cancel' ];\n\nconst pointerEvents = {\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  signals,\n  defaults: {\n    holdDuration: 600,\n    ignoreFrom  : null,\n    allowFrom   : null,\n    origin      : { x: 0, y: 0 },\n  },\n  types: [\n    'down',\n    'move',\n    'up',\n    'cancel',\n    'tap',\n    'doubletap',\n    'hold',\n  ],\n};\n\nfunction fire (arg) {\n  const {\n    interaction, pointer, event, eventTarget,\n    type = arg.pointerEvent.type,\n    targets = collectEventTargets(arg),\n    pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction),\n  } = arg;\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  };\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i];\n\n    for (const prop in target.props || {}) {\n      pointerEvent[prop] = target.props[prop];\n    }\n\n    const origin = utils.getOriginXY(target.eventable, target.element);\n\n    pointerEvent.subtractOrigin(origin);\n    pointerEvent.eventable = target.eventable;\n    pointerEvent.currentTarget = target.element;\n\n    target.eventable.fire(pointerEvent);\n\n    pointerEvent.addOrigin(origin);\n\n    if (pointerEvent.immediatePropagationStopped\n        || (pointerEvent.propagationStopped\n            && (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\n      break;\n    }\n  }\n\n  signals.fire('fired', signalArg);\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire({\n        interaction, pointer, event, eventTarget,\n        type: 'doubletap',\n      })\n      : pointerEvent;\n\n    interaction.prevTap = prevTap;\n    interaction.tapTime = prevTap.timeStamp;\n  }\n\n  return pointerEvent;\n}\n\nfunction collectEventTargets ({ interaction, pointer, event, eventTarget, type }) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (type === 'tap' && (interaction.pointerWasMoved\n      // or if the pointerup target is different to the pointerdown target\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return [];\n  }\n\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [],\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(target =>\n      target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration);\n  }\n\n  return signalArg.targets;\n}\n\nInteraction.signals.on('update-pointer-down', function ({ interaction, pointerIndex }) {\n  interaction.holdTimers[pointerIndex] = { duration: Infinity, timeout: null };\n});\n\nInteraction.signals.on('remove-pointer', function ({ interaction, pointerIndex }) {\n  interaction.holdTimers.splice(pointerIndex, 1);\n});\n\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n\n    fire({\n      interaction, pointer, event, eventTarget,\n      type: 'move',\n    });\n  }\n});\n\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\n  const timer = interaction.holdTimers[pointerIndex];\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [],\n    path,\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (!signalArg.targets.length) { return; }\n\n  let minDuration = Infinity;\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration;\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration;\n    }\n  }\n\n  timer.duration = minDuration;\n  timer.timeout = setTimeout(function () {\n    fire({\n      interaction,\n      eventTarget,\n      pointer,\n      event,\n      type: 'hold',\n    });\n  }, minDuration);\n});\n\nInteraction.signals.on('up', ({ interaction, pointer, event, eventTarget }) => {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' });\n  }\n});\n\nfor (const signalName of ['up', 'cancel']) {\n  Interaction.signals.on(signalName, function ({ interaction, pointerIndex }) {\n    if (interaction.holdTimers[pointerIndex]) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n  });\n}\n\nfunction createSignalListener (type) {\n  return function ({ interaction, pointer, event, eventTarget }) {\n    fire({ interaction, eventTarget, pointer, event, type });\n  };\n}\n\nfor (let i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap    = null;  // the most recent tap event on this interaction\n  interaction.tapTime    = 0;     // time of the most recent tap event\n  interaction.holdTimers = [];    // [{ duration, timeout }]\n});\n\ndefaults.pointerEvents = pointerEvents.defaults;\nmodule.exports = pointerEvents;\n","const pointerEvents = require('./base');\nconst Interaction   = require('../Interaction');\n\npointerEvents.signals.on('new', onNew);\npointerEvents.signals.on('fired', onFired);\n\nfor (const signal of ['move', 'up', 'cancel', 'endall']) {\n  Interaction.signals.on(signal, endHoldRepeat);\n}\n\nfunction onNew ({ pointerEvent }) {\n  if (pointerEvent.type !== 'hold') { return; }\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\n}\n\nfunction onFired ({ interaction, pointerEvent, eventTarget, targets }) {\n  if (pointerEvent.type !== 'hold' || !targets.length) { return; }\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval;\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) { return; }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(function () {\n    pointerEvents.fire({\n      interaction,\n      eventTarget,\n      type: 'hold',\n      pointer: pointerEvent,\n      event: pointerEvent,\n    });\n  }, interval);\n}\n\nfunction endHoldRepeat ({ interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle);\n    interaction.holdIntervalHandle = null;\n  }\n}\n\n// don't repeat by default\npointerEvents.defaults.holdRepeatInterval = 0;\npointerEvents.types.push('holdrepeat');\n\nmodule.exports = {\n  onNew,\n  onFired,\n  endHoldRepeat,\n};\n","const pointerEvents = require('./base');\nconst Interactable  = require('../Interactable');\nconst is            = require('../utils/is');\nconst scope         = require('../scope');\nconst extend        = require('../utils/extend');\nconst { merge }     = require('../utils/arr');\n\npointerEvents.signals.on('collect-targets', function ({ targets, element, type, eventTarget }) {\n  scope.interactables.forEachMatch(element, interactable => {\n    const eventable = interactable.events;\n    const options = eventable.options;\n\n    if (eventable[type]\n      && is.element(element)\n      && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n      targets.push({\n        element,\n        eventable,\n        props: { interactable },\n      });\n    }\n  });\n});\n\nInteractable.signals.on('new', function ({ interactable }) {\n  interactable.events.getRect = function (element) {\n    return interactable.getRect(element);\n  };\n});\n\nInteractable.signals.on('set', function ({ interactable, options }) {\n  extend(interactable.events.options, pointerEvents.defaults);\n  extend(interactable.events.options, options);\n});\n\nmerge(Interactable.eventTypes, pointerEvents.types);\n\nInteractable.prototype.pointerEvents = function (options) {\n  extend(this.events.options, options);\n\n  return this;\n};\n\nconst __backCompatOption = Interactable.prototype._backCompatOption;\n\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\n  const ret = __backCompatOption.call(this, optionName, newValue);\n\n  if (ret === this) {\n    this.events.options[optionName] = newValue;\n  }\n\n  return ret;\n};\n\nInteractable.settingsMethods.push('pointerEvents');\n","const utils   = require('./utils');\nconst events  = require('./utils/events');\nconst signals = require('./utils/Signals').new();\n\nconst { getWindow } = require('./utils/window');\n\nconst scope = {\n  signals,\n  events,\n  utils,\n\n  // main document\n  document: require('./utils/domObjects').document,\n  // all documents being listened to\n  documents: [],\n\n  addDocument: function (doc, win) {\n    // do nothing if document is already known\n    if (utils.contains(scope.documents, doc)) { return false; }\n\n    win = win || getWindow(doc);\n\n    scope.documents.push(doc);\n    events.documents.push(doc);\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== scope.document) {\n      events.add(win, 'unload', scope.onWindowUnload);\n    }\n\n    signals.fire('add-document', { doc, win });\n  },\n\n  removeDocument: function (doc, win) {\n    const index = scope.documents.indexOf(doc);\n\n    win = win || getWindow(doc);\n\n    events.remove(win, 'unload', scope.onWindowUnload);\n\n    scope.documents.splice(index, 1);\n    events.documents.splice(index, 1);\n\n    signals.fire('remove-document', { win, doc });\n  },\n\n  onWindowUnload: function () {\n    scope.removeDocument(this.document, this);\n  },\n};\n\nmodule.exports = scope;\n","class Signals {\n  constructor () {\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  on (name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  }\n\n  off (name, listener) {\n    if (!this.listeners[name]) { return; }\n\n    const index = this.listeners[name].indexOf(listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  }\n\n  fire (name, arg) {\n    const targetListeners = this.listeners[name];\n\n    if (!targetListeners) { return; }\n\n    for (const listener of targetListeners) {\n      if (listener(arg, name) === false) {\n        return;\n      }\n    }\n  }\n}\n\nSignals.new = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n","function contains (array, target) {\n  return array.indexOf(target) !== -1;\n}\n\nfunction merge (target, source) {\n  for (const item of source) {\n    target.push(item);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  contains,\n  merge,\n};\n","const { window } = require('./window');\nconst is     = require('./is');\nconst domObjects = require('./domObjects');\n\nconst Element = domObjects.Element;\nconst navigator  = window.navigator;\n\nconst browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!(('ontouchstart' in window) || is.function(window.DocumentTouch)\n                     && domObjects.document instanceof window.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIOS: (/iP(hone|od|ad)/.test(navigator.platform)),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n  isIe9: /MSIE 9/.test(navigator.userAgent),\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\n    ? 'oMatchesSelector': 'msMatchesSelector',\n\n  pEventTypes: (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up:     'MSPointerUp',\n        down:   'MSPointerDown',\n        over:   'mouseover',\n        out:    'mouseout',\n        move:   'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up:     'pointerup',\n        down:   'pointerdown',\n        over:   'pointerover',\n        out:    'pointerout',\n        move:   'pointermove',\n        cancel: 'pointercancel',\n      })\n    : null),\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent: 'onmousewheel' in domObjects.document? 'mousewheel': 'wheel',\n\n};\n\n// Opera Mobile must be handled differently\nbrowser.isOperaMobile = (navigator.appName === 'Opera'\n  && browser.supportsTouch\n  && navigator.userAgent.match('Presto'));\n\nmodule.exports = browser;\n","const is = require('./is');\n\nmodule.exports = function clone (source) {\n  const dest = {};\n  for (const prop in source) {\n    if (is.plainObject(source[prop])) {\n      dest[prop] = clone(source[prop]);\n    } else {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n};\n","const domObjects = {};\nconst win = require('./window').window;\n\nfunction blank () {}\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.Element            = win.Element            || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || domObjects.Element;\n\ndomObjects.Event        = win.Event;\ndomObjects.Touch        = win.Touch || blank;\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n","const win        = require('./window');\nconst browser    = require('./browser');\nconst is         = require('./is');\nconst domObjects = require('./domObjects');\n\nconst domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (element, selector) {\n    while (is.element(element)) {\n      if (domUtils.matchesSelector(element, selector)) { return element; }\n\n      element = domUtils.parentNode(element);\n    }\n\n    return null;\n  },\n\n  parentNode: function (node) {\n    let parent = node.parentNode;\n\n    if (is.docFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && is.docFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  matchesSelector: function (element, selector) {\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    let deepestZoneParents = [];\n    let dropzoneParents = [];\n    let dropzone;\n    let deepestZone = elements[0];\n    let index = deepestZone? 0: -1;\n    let parent;\n    let child;\n    let i;\n    let n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement\n          && dropzone instanceof domObjects.SVGElement\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      const parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n],\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (is.element(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentNode(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return (element instanceof domObjects.SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n    };\n  },\n\n  getElementClientRect: function (element) {\n    const clientRect = (element instanceof domObjects.SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width  || clientRect.right  - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    };\n  },\n\n  getElementRect: function (element) {\n    const clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  },\n\n  getPath: function (element) {\n    const path = [];\n\n    while (element) {\n      path.push(element);\n      element = domUtils.parentNode(element);\n    }\n\n    return path;\n  },\n\n  trySelector: value => {\n    if (!is.string(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  },\n};\n\nmodule.exports = domUtils;\n","const is           = require('./is');\nconst domUtils     = require('./domUtils');\nconst pointerUtils = require('./pointerUtils');\nconst pExtend      = require('./pointerExtend');\n\nconst { window }   = require('./window');\nconst { contains } = require('./arr');\n\nconst elements = [];\nconst targets  = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, capture, passive], ...]\n//   }\n//  }\nconst delegatedEvents = {};\nconst documents       = [];\n\nconst supportsOptions = (() => {\n  let supported = false;\n\n  window.document.createElement('div').addEventListener('test', null, {\n    get capture () { supported = true; },\n  });\n\n  return supported;\n})();\n\nfunction add (element, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  let elementIndex = elements.indexOf(element);\n  let target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    element.addEventListener(type, listener, supportsOptions? options : !!options.capture);\n    target.events[type].push(listener);\n  }\n}\n\nfunction remove (element, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  const elementIndex = elements.indexOf(element);\n  const target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], options);\n      }\n      return;\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element.removeEventListener(`on${type}`, listener, supportsOptions? options : !!options.capture);\n          target.events[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate (selector, context, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts : [],\n      listeners: [],\n    };\n\n    // add delegate listener functions\n    for (const doc of documents) {\n      add(doc, type, delegateListener);\n      add(doc, type, delegateUseCapture, true);\n    }\n  }\n\n  const delegated = delegatedEvents[type];\n  let index;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts .push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and capture and passive flags\n  delegated.listeners[index].push([listener, !!options.capture, options.passive]);\n}\n\nfunction removeDelegate (selector, context, type, listener, optionalArg) {\n  const options = getOptions(optionalArg);\n  const delegated = delegatedEvents[type];\n  let matchFound = false;\n  let index;\n\n  if (!delegated) { return; }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n\n      const listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, capture, passive]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const [fn, capture, passive] = listeners[i];\n\n        // check if the listener functions and capture and passive flags match\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts .splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) { break; }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event, optionalArg) {\n  const options = getOptions(optionalArg);\n  const fakeEvent = {};\n  const delegated = delegatedEvents[event.type];\n  const [eventTarget] = (pointerUtils.getEventTargets(event));\n  let element = eventTarget;\n\n  // duplicate the event so that currentTarget can be changed\n  pExtend(fakeEvent, event);\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (is.element(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i];\n      const context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector)\n          && domUtils.nodeContains(context, eventTarget)\n          && domUtils.nodeContains(context, element)) {\n\n        const listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (let j = 0; j < listeners.length; j++) {\n          const [fn, capture, passive] = listeners[j];\n\n          if (capture === !!options.capture && passive === options.passive) {\n            fn(fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element);\n  }\n}\n\nfunction delegateUseCapture (event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction getOptions (param) {\n  return is.object(param)? param : { capture: param };\n}\n\nmodule.exports = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  supportsOptions,\n\n  _elements: elements,\n  _targets: targets,\n};\n","module.exports = function extend (dest, source) {\n  for (const prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n","const {\n  resolveRectLike,\n  rectToXY,\n} = require('./rect');\n\nmodule.exports = function (target, element, action) {\n  const actionOptions = target.options[action];\n  const actionOrigin = actionOptions && actionOptions.origin;\n  const origin = actionOrigin || target.options.origin;\n\n  const originRect = resolveRectLike(origin, target, element, [target && element]);\n\n  return rectToXY(originRect) || { x: 0, y: 0 };\n};\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\n","const extend = require('./extend');\nconst win    = require('./window');\n\nconst utils = {\n  warnOnce: function (method, message) {\n    let warned = false;\n\n    return function () {\n      if (!warned) {\n        win.window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  },\n\n  // http://stackoverflow.com/a/5634528/2280888\n  _getQBezierValue: function (t, p1, p2, p3) {\n    const iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  },\n\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x:  utils._getQBezierValue(position, startX, cpX, endX),\n      y:  utils._getQBezierValue(position, startY, cpY, endY),\n    };\n  },\n\n  // http://gizma.com/easing/\n  easeOutQuad: function (t, b, c, d) {\n    t /= d;\n    return -c * t*(t-2) + b;\n  },\n\n  copyAction: function (dest, src) {\n    dest.name  = src.name;\n    dest.axis  = src.axis;\n    dest.edges = src.edges;\n\n    return dest;\n  },\n\n  is         : require('./is'),\n  extend     : extend,\n  hypot      : require('./hypot'),\n  getOriginXY: require('./getOriginXY'),\n};\n\nextend(utils, require('./arr'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\nextend(utils, require('./rect'));\n\nmodule.exports = utils;\n","const scope   = require('../scope');\nconst utils   = require('./index');\n\nconst finder = {\n  methodOrder: [ 'simulationResume', 'mouseOrPen', 'hasPointer', 'idle' ],\n\n  search: function (pointer, eventType, eventTarget) {\n    const pointerType = utils.getPointerType(pointer);\n    const pointerId = utils.getPointerId(pointer);\n    const details = { pointer, pointerId, pointerType, eventType, eventTarget };\n\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function ({ pointerType, eventType, eventTarget }) {\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (const interaction of scope.interactions) {\n      let element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume\n          && (interaction.pointerType === pointerType)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentNode(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen: function ({ pointerId, pointerType, eventType }) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null;\n    }\n\n    let firstNonActive;\n\n    for (const interaction of scope.interactions) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) { continue; }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction;\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function ({ pointerId }) {\n    for (const interaction of scope.interactions) {\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle: function ({ pointerType }) {\n    for (const interaction of scope.interactions) {\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        const target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n        continue;\n      }\n\n      if (!interaction.interacting() && (pointerType === interaction.pointerType)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n};\n\nmodule.exports = finder;\n","const win        = require('./window');\nconst isWindow   = require('./isWindow');\n\nconst is = {\n  array   : () => {},\n\n  window  : thing => thing === win.window || isWindow(thing),\n\n  docFrag : thing => is.object(thing) && thing.nodeType === 11,\n\n  object  : thing => !!thing && (typeof thing === 'object'),\n\n  function: thing => typeof thing === 'function',\n\n  number  : thing => typeof thing === 'number'  ,\n\n  bool    : thing => typeof thing === 'boolean' ,\n\n  string  : thing => typeof thing === 'string'  ,\n\n  element: thing => {\n    if (!thing || (typeof thing !== 'object')) { return false; }\n\n    const _window = win.getWindow(thing) || win.window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? thing instanceof _window.Element //DOM2\n      : thing.nodeType === 1 && typeof thing.nodeName === 'string');\n  },\n\n  plainObject: thing => is.object(thing) && thing.constructor.name === 'Object',\n};\n\nis.array = thing => (is.object(thing)\n  && (typeof thing.length !== 'undefined')\n  && is.function(thing.splice));\n\nmodule.exports = is;\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\n","function pointerExtend (dest, source) {\n  for (const prop in source) {\n    const prefixedPropREs = module.exports.prefixedPropREs;\n    let deprecated = false;\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true;\n        break;\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n};\n\nmodule.exports = pointerExtend;\n","const hypot         = require('./hypot');\nconst browser       = require('./browser');\nconst dom           = require('./domObjects');\nconst domUtils      = require('./domUtils');\nconst domObjects    = require('./domObjects');\nconst is            = require('./is');\nconst pointerExtend = require('./pointerExtend');\n\nconst pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setCoordDeltas: function (targetObj, prev, cur) {\n    targetObj.page.x    = cur.page.x    - prev.page.x;\n    targetObj.page.y    = cur.page.y    - prev.page.y;\n    targetObj.client.x  = cur.client.x  - prev.client.x;\n    targetObj.client.y  = cur.client.y  - prev.client.y;\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n    // set pointer velocity\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return is.number(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  },\n\n  setCoords: function (targetObj, pointers, timeStamp) {\n    const pointer = (pointers.length > 1\n                     ? pointerUtils.pointerAverage(pointers)\n                     : pointers[0]);\n\n    const tmpXY = {};\n\n    pointerUtils.getPageXY(pointer, tmpXY);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = is.number(timeStamp) ? timeStamp :new Date().getTime();\n  },\n\n  pointerExtend: pointerExtend,\n\n  getTouchPair: function (event) {\n    const touches = [];\n\n    // array of touches is supplied\n    if (is.array(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    };\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    const touches = pointerUtils.getTouchPair(event);\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n\n\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n    const dx = touches[1][sourceX] - touches[0][sourceX];\n    const dy = touches[1][sourceY] - touches[0][sourceY];\n    const angle = 180 * Math.atan2(dy , dx) / Math.PI;\n\n    return  angle;\n  },\n\n  getPointerType: function (pointer) {\n    return is.string(pointer.pointerType)\n      ? pointer.pointerType\n      : is.number(pointer.pointerType)\n        ? [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType]\n          // if the PointerEvent API isn't available, then the \"pointer\" must\n          // be either a MouseEvent, TouchEvent, or Touch object\n          : /touch/.test(pointer.type) || pointer instanceof domObjects.Touch\n            ? 'touch'\n            : 'mouse';\n  },\n\n  // [ event.target, event.currentTarget ]\n  getEventTargets: function (event) {\n    const path = is.function(event.composedPath) ? event.composedPath() : event.path;\n\n    return [\n      domUtils.getActualElement(path ? path[0] : event.target),\n      domUtils.getActualElement(event.currentTarget),\n    ];\n  },\n};\n\nmodule.exports = pointerUtils;\n","const { window } = require('./window');\n\nconst vendors = ['ms', 'moz', 'webkit', 'o'];\nlet lastTime = 0;\nlet request;\nlet cancel;\n\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    const currTime = new Date().getTime();\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\n                          timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request,\n  cancel,\n};\n","const extend = require('./extend');\nconst is = require('./is');\nconst {\n  closest,\n  parentNode,\n  getElementRect,\n} = require('./domUtils');\n\nconst rectUtils = {\n  getStringOptionResult: function (value, interactable, element) {\n    if (!is.string(value)) {\n      return null;\n    }\n\n    if (value === 'parent') {\n      value = parentNode(element);\n    }\n    else if (value === 'self') {\n      value = interactable.getRect(element);\n    }\n    else {\n      value = closest(element, value);\n    }\n\n    return value;\n  },\n\n  resolveRectLike: function (value, interactable, element, functionArgs) {\n    value = rectUtils.getStringOptionResult(value, interactable, element) || value;\n\n    if (is.function(value)) {\n      value = value.apply(null, functionArgs);\n    }\n\n    if (is.element(value)) {\n      value = getElementRect(value);\n    }\n\n    return value;\n  },\n\n  rectToXY: function (rect) {\n    return  rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    };\n  },\n\n  xywhToTlbr: function (rect) {\n    if (rect && !('left' in rect && 'top' in rect)) {\n      rect = extend({}, rect);\n\n      rect.left   = rect.x || 0;\n      rect.top    = rect.y || 0;\n      rect.right  = rect.right   || (rect.left + rect.width);\n      rect.bottom = rect.bottom  || (rect.top + rect.height);\n    }\n\n    return rect;\n  },\n\n  tlbrToXywh: function (rect) {\n    if (rect && !('x' in rect && 'y' in rect)) {\n      rect = extend({}, rect);\n\n      rect.x      = rect.left || 0;\n      rect.top    = rect.top  || 0;\n      rect.width  = rect.width  || (rect.right  - rect.x);\n      rect.height = rect.height || (rect.bottom - rect.y);\n    }\n\n    return rect;\n  },\n};\n\nmodule.exports = rectUtils;\n","const win = module.exports;\nconst isWindow = require('./isWindow');\n\nfunction init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  const el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document\n      && typeof window.wrap === 'function'\n    && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window);\n  }\n\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined;\n  win.realWindow = undefined;\n}\nelse {\n  init(window);\n}\n\nwin.getWindow = function getWindow (node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  const rootNode = (node.ownerDocument || node);\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}